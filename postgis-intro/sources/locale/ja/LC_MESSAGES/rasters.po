# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2023, Paul Ramsey | Mark Leslie | PostGIS contributors
# This file is distributed under the same license as the Introduction to
# PostGIS package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
# Teramoto Ikuhiro <yellow@affrc.go.jp>, 2023, 2024.
msgid ""
msgstr "Project-Id-Version: Introduction to PostGIS 1.1\nReport-Msgid-Bugs-To: \nPOT-Creation-Date: 2023-03-17 01:29-0400\nPO-Revision-Date: 2024-02-23 03:45+0000\nLast-Translator: Teramoto Ikuhiro <yellow@affrc.go.jp>\nLanguage-Team: Japanese <https://weblate.osgeo.org/projects/postgis-workshop/rasters/ja/>\nLanguage: ja\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nPlural-Forms: nplurals=1; plural=0;\nX-Generator: Weblate 5.3\nGenerated-By: Babel 2.11.0\n"

#: ../../en/rasters.rst:4
msgid "Rasters"
msgstr "ラスタ"

#: ../../en/rasters.rst:6
msgid "PostGIS supports another kind of spatial data type called a *raster*. Raster data, much like geometry data, uses **Cartesian coordinates** and a spatial reference system. However instead of vector data, raster data is represented as an n-dimensional matrix consisting of pixels and bands. The bands defines the number of matrices you have. Each pixel stores a value corresponding to each band. So a 3-banded raster such as an RGB image, would have 3 values for each pixel corresponding to the Red-Green-Blue bands."
msgstr "PostGIS は *raster* という、これまでと別の空間データ型を持っています。ラスタデータはジオメトリデータと同じで **直交座標** と空間参照系を使用します。しかし、ラスタデータはベクタデータと違い、ピクセルとバンドで構成される n次元行列 として表されます。バンドは持っている行列の数を定義します。ピクセルはそれぞれが、バンドに対応する値を格納します。RGB画像のような 3バンドラスタ では、ピクセルはおのおの、赤、緑、青のバンドに対応する三つの値を持ちます。"

#: ../../en/rasters.rst:12
msgid "Although pretty pictures such as those you see on your TV screen are rasters, rasters may not be that exciting to look at. In a nutshell, a raster is a matrix, pinned on a coordinate system, that has values that can represent anything you want them to represent."
msgstr "テレビ画面で見るようなきれいな画像もラスタですが、ラスタは見ても大して楽しくないこともあります。一言で言うと、ラスタは、座標系に固定された、表現したいものを表現できる値を持つ行列です。"

#: ../../en/rasters.rst:17
msgid "Since rasters live in cartesian space, rasters can interact with geometries. PostGIS offers many functions that take as input both rasters and geometries. Many operations applied to rasters will result in geometries. Common ones are the `ST_Polygon`, `ST_Envelope`, `ST_ConvexHull`, and `ST_MinConvexHull` as shown below.  When you cast a raster to a geometry, what is output is the `ST_ConvexHull` of the raster."
msgstr "ラスタがデカルト空間内に存在するので、ラスタはジオメトリとの相互作用が可能です。PostGIS は、ラスタとジオメトリの両方を入力に取る関数を多数提供しています。一般的なものとしては、下の図に示す `ST_Polygon`, `ST_Envelope`, `ST_ConvexHull`, `ST_MinConvexHull` です。ラスタをジオメトリにキャストすると、出力はラスタの `ST_ConvexHull` です。"

#: ../../en/rasters.rst:24
msgid "The raster format is commonly used to store elevation data, temperature data, satellite data, and thematic data representing things like environmental contamination, population density, and environmental hazard occurrences. You can use rasters to store any numeric data that has a meaningful coordinate location. The only restriction is that for all data in a specific band the numeric data types have to be the same."
msgstr "ラスタ形式は一般的に標高データ、気温データ、衛星データ、環境汚染、人口密度、環境危険の発生などを表現する主題データなどを格納するためによく使あｗレ増す。意味のある座標位置を持つ数値データの格納のためにラスタを使用することができます。ラスタの制限は、特定のバンドの全てのデータについて、数値データタイプが同じでなければならないことだけです。"

#: ../../en/rasters.rst:28
msgid "Although raster data can be created from scratch in PostGIS, a more common approach is to load raster data from various formats using the :command:`raster2pgsql` command line tool packaged with PostGIS. Before all of that, you must enable raster support in your database by running the command:"
msgstr "ラスタデータは PostGIS で何もない状態から作成できますが、PostGIS に同梱されている :command:`raster2pgsql` コマンドラインツールを使って、様々なフォーマットのラスタデータをロードするのが一般的です。その前に、データベースのラスタ対応を有効にしないといけません。次のようにします:"

#: ../../en/rasters.rst:37
msgid "Creating Rasters From Geometries"
msgstr "ジオメトリからラスタを作る"

#: ../../en/rasters.rst:38
msgid "We'll start off by first creating raster data from vector data, and then move on to the more exciting approach of loading data from a raster source. You will find that raster data is available in abundance and often free from various government sites."
msgstr "ベクタデータからラスタデータ生成を最初に始め、より刺激的となるラスタソースからデータをロードするアプローチに移ります。ラスタデータが多量に存在し、しばしば様々な政府サイトから無償で入手できます。"

#: ../../en/rasters.rst:41
msgid "We'll start by converting some geometries into rasters using `ST_AsRaster <https://postgis.net/docs/RT_ST_AsRaster.html>`_ function as follows."
msgstr "次の通り、`ST_AsRaster <https://postgis.net/docs/ja/RT_ST_AsRaster.html>`_ 関数ジオメトリをラスタに変換することから始めます。"

#: ../../en/rasters.rst:55
msgid "The above example CREATEs a table (**rasters**) from geometries formed from letters using the PostGIS 3.2+ `ST_Letters <https://postgis.net/docs/ST_Letters.html>`_ function. Rasters similar to geometries, can take advantage of spatial indexes. The spatial index used for raster is a functional index that indexes the geometry convexhull of the raster."
msgstr "上の例で、文字から形成されるジオメトリからテーブル (**ラスタ**) を CREATE します。PostGIS 3.2 以上の `ST_Letters <https://postgis.net/docs/ja/ST_Letters.html>`_ を使います。ラスタはジオメトリに似ていて、空か人デックスを利用できます。ラスタに使われる空間インデックスは、ラスタの凸包ジオメトリを使った関数インデックスを使用します。"

#: ../../en/rasters.rst:58
msgid "You can see some useful metadata of your rasters with the following query which utilizes the postgis raster `ST_Count <https://postgis.net/docs/RT_ST_Count.html>`_ function to count the number of pixels that have data and the `ST_MetaData <https://postgis.net/docs/RT_ST_MetaData.html>`_ function to provide all sorts of useful background info for our rasters."
msgstr "次のクエリで便利なラスタのメタデータを見ることができます。データを持つピクセルの数を数える `ST_Count <https://postgis.net/docs/ja/RT_ST_Count.html>`_ 関数と、ラスタの便利な背景情報の全ての種類を提供する ST_MetaData <https://postgis.net/docs/ja/RT_ST_MetaData.html>`_ 関数を使っています。"

#: ../../en/rasters.rst:76
msgid "There are two levels of raster functions. There are functions such as ST_MetaData that work at the raster level and there are functions such as :command:`ST_Count` function and `ST_BandMetaData <https://postgis.net/docs/RT_ST_BandMetaData.html>`_ function that work at the band level. Most functions in postgis raster that work at the band level, work with only one band at a time, and assume the band you want is `1`."
msgstr "ラスタ関数の二つのレベルがあります。ST_MetaData などのラスタレベルで動作する関数と、 :command:`ST_Count` 関数や `ST_BandMetaData <https://postgis.net/docs/ja/RT_ST_BandMetaData.html>`_ 関数などのバンドレベルで動作する関数です。PostGISラスタ 関数のうちバンドレベルで動作するものは、ほとんどが一度に 1バンド で動作し、渡したいバンドの番号を 1 と仮定します。"

#: ../../en/rasters.rst:83
msgid "If you have a multi-band raster, and you need to count the pixel not no-data values in a band other than 1, you would explicitly specify the band number as follows `ST_Count(rast,2)`."
msgstr "複数バンドのラスタで、1番 以外のバンドで、NODATA値 でないピクセルのカウントを行いたい場合には、`ST_Count(rast,2)` のように、明示的にバンド番号を与えます。"

#: ../../en/rasters.rst:85
msgid "Note how all the rasters have a 150x150 dimension.  This is not ideal. This means that in order to force that, our rasters, are squished in all sorts of ways.  If only we could see the ugliness of the rasters before us."
msgstr "全てのラスタのピクセル数が 150x150 になっていることに注意して下さい。これは理想的ではありません。ピクセル数を強制するために、ラスタが全方向で押しつぶされることになります。目の前のラスタの醜さを見ることができたらいいのですができません。"

#: ../../en/rasters.rst:89
msgid "Loading Rasters using raster2pgsql"
msgstr "ラスタを raster2pgsql を使ってロードする"

#: ../../en/rasters.rst:90
msgid "`raster2pgsql <https://postgis.net/docs/using_raster_dataman.html#RT_Raster_Loader>`_ is a command-line tool often packaged with PostGIS. If you are on windows and used application stackbuilder PostGIS Bundle, you'll find :command:`raster2pgsql.exe` in the folder ``C:\\Program Files\\PostgreSQL\\15\\bin``  where the *15* should be replaced with the version of PostgreSQL you are running."
msgstr "`raster2pgsql <https://postgis.net/docs/ja/using_raster_dataman.html#RT_Raster_Loader>`_ は、PostGIS によく同梱されているコマンドラインツールです。Windows 上でスタックビルダの PostGIS Bundle を使っている場合には、``C:\\Program Files\\PostgreSQL\\15\\bin`` フォルダ内に :command:`raster2pgsql.exe` があります。なおフォルダ名の *15* は、実行している PostgreSQL のバージョンによって異なります。"

#: ../../en/rasters.rst:93
msgid "If you are using Postgres.App, you'll find raster2pgsql among the other `Postgres.app CLI Tools <https://postgresapp.com/documentation/cli-tools.html>`_."
msgstr "Postgres.App を使用している場合には、他の `Postgres.app CLI Tools <https://postgresapp.com/documentation/cli-tools.html>`_ の中に raster2pgsql があります。"

#: ../../en/rasters.rst:95
msgid "On Ubuntu and Debian, you will need"
msgstr "Ubuntu や Debian では、次を実行して下さい"

#: ../../en/rasters.rst:101
msgid "to have the PostGIS commandline tools installed. This may install an additional version of PostgreSQL as well. You can see a list of clusters in Debian/Ubuntu using the :command:`pg_lsclusters` command and drop them using the :command:`pg_dropcluster` command."
msgstr "これで PostGIS コマンドラインツールがインストールされます。PostgreSQL の追加バージョンもインストールされる可能性があります。:command:`pg_lsclusters` コマンドを使って Degiab/Ubuntu 内のクラスタの一覧を見ることができます。:command:`pg_dropcluster` コマンドを使って削除できます。"

#: ../../en/rasters.rst:106
msgid "For this and later exercises, we'll be using `nyc_dem.tif` found in the file `PG Raster Workshop Dataset https://postgis.net/stuff/workshop-data/postgis_raster_workshop.zip <https://postgis.net/stuff/workshop-data/postgis_raster_workshop.zip>`_. For some geometry/raster examples, we will also be using NYC data loaded from prior chapters.  In-lieu of loading the tif, you can restore the `nyc_dem.backup` included in the zip file in your database using the :command:`pg_restore` commandline tool or the pgAdmin **Restore** menu."
msgstr "これ以後の演習では、`PG Raster Workshop Dataset https://postgis.net/stuff/workshop-data/postgis_raster_workshop.zip <https://postgis.net/stuff/workshop-data/postgis_raster_workshop.zip>`_ 内にある `nyc_dem.tif` を使用します。ジオメトリ/ラスタの例では、以前の章でロードしたニューヨーク市データも使います。TIFF ファイルのロードの代わりに、:command:`pg_restore` コマンドラインツールか、pgAdmin の **Restore** メニューを使って、データベース内の ZIPファイル に含まれる `nyc_dem.backup` を復元できます。"

#: ../../en/rasters.rst:112
msgid "This raster data was sourced from `NYC DEM 1-foot Integer <https://data.cityofnewyork.us/City-Government/1-foot-Digital-Elevation-Model-DEM-/dpc8-z3jc>`_ which is a 3GB DEM tif representing elevation relative to sea level with buildings and overwater removed. We then created a lower res version of it."
msgstr "このラスタデータは、建物と水面を除いた、海面からの相対高度を表現する 3GB DEM の TIFFデータ である `NYC DEM 1-foot Integer <https://data.cityofnewyork.us/City-Government/1-foot-Digital-Elevation-Model-DEM-/dpc8-z3jc>`_ をもとにした低解像度版です。"

#: ../../en/rasters.rst:115
msgid "The :command:`rasterpgsql` tool is similar to the :command:`shp2gpsql` except instead of loading ESRI shapefiles into PostGIS geometry/geography tables, it loads any GDAL supported raster format into raster tables. Just like :command:`shp2pgsql` you can pass it a spatial reference id (SRID) of the source. Unlike :command:`shp2pgsql` it can infer the spatial references system of the source data if your source data has suitable metadata."
msgstr ":command:`rasterpgsql` ツールは、ESRIシェープファイル を PostGIS ジオメトリ/ジオグラフィテーブルにロードする代わりに、GDAL が対応するラスタフォーマットをラスタテーブルにロードするところが違いますが、 :command:`shp2gpsql` と似ています。:command:`shp2pgsql` のように、ソースデータの空間参照系ID (SRID) を渡すことができます。:command:`shp2pgsql` と違い、適切なメタデータを持っているソースデータに対しては空間参照系を推測できます。"

#: ../../en/rasters.rst:119
msgid "For a full exposure of all the possible switches offered refer to `raster2pgsql options <https://postgis.net/docs/using_raster_dataman.html#RT_Loading_Rasters>`_."
msgstr "全ての可能性のあるスイッチに関する完全な情報は `raster2pgsqlオプション <https://postgis.net/docs/ja/using_raster_dataman.html#RT_Loading_Rasters>`_ にあります。"

#: ../../en/rasters.rst:121
msgid "Some other notable options :command:`raster2pgsql` offers which we will not cover are:"
msgstr "他の:command:`raster2pgsql` が提供する特筆すべきですが、ここでは紹介しないオプションには次のものがあります:"

#: ../../en/rasters.rst:123
msgid "Ability to denote the SRID of the source. Instead, we'll rely on raster2pgsql guessing skills."
msgstr "ソースの SRID を表示する能力。代わりに raster2pgsql の推測スキルに頼ることになります。"

#: ../../en/rasters.rst:124
msgid "Ability to set the `nodata` value, when not specified, raster2pgsql tries to infer from the file."
msgstr "`nodata`値 を設定する機能で、指定しない場合には raster2pgsql はファイルから推測を試みます。"

#: ../../en/rasters.rst:125
msgid "Abiliity to load out-of-database rasters."
msgstr "データベース外ラスタのロード機能。"

#: ../../en/rasters.rst:127
msgid "To load all the tif files in our folder and also create overviews, we would run the below."
msgstr "現在のフォルダにある全ての TIFFファイル をロードし、オーバビューを生成するには、以下を実行します。"

#: ../../en/rasters.rst:133
msgid "-d to drop the tables if they already exist"
msgstr "-d テーブルが既に存在している場合には削除します"

#: ../../en/rasters.rst:134
msgid "The above command uses `-e` to do load immediately instead of committing in a transaction"
msgstr "上のコマンドは、トランザクションでコミットする代わりにすぐにロードを実行するために `-e` を使います"

#: ../../en/rasters.rst:135
msgid "`-C` set raster constraints, this is useful for `raster_columns` to show info. You may want to combine with `-x` to exclude the extent constraint, which is a slow constraint to check and also hampers future loads in the table."
msgstr "`-C` ラスタ制約を設定します。`raster_columns` が情報を表示するのに便利です。範囲制約を除外するために `-x` を使っても構いません。範囲制約はチェックに時間がかかったり、テーブル内の将来のロードを妨げ制約です。"

#: ../../en/rasters.rst:138
msgid "`-M` to vacuum and analyze after load, to improve query planner statistics"
msgstr "`-M` ロード後に VACUUM と ANALYZE を実行して、クエリプランナの統計情報を改善します"

#: ../../en/rasters.rst:139
msgid "`-Y` to use copy in batches of 50. If you are running PostGIS 3.3 or higher, you can use `-Y 1000` to have copy be in batches of 1000, or even higher number. This will run faster, but will use more memory."
msgstr "`-Y` 50個のバッチで COPY を使用します。PostGIS 3.3 以上では、`-Y 1000` とすると、COPY を 1000のバッチにすることができますし、もっと大きい値にすることができます。早くなる半面、使用メモリも多くなります。"

#: ../../en/rasters.rst:141
msgid "`-l 2,3` to create over view tables: `o_2_ncy_dem` and `o_3_nyc_dem`. This is useful for viewing data."
msgstr "`-l 2,3` オーバビューテーブルを作成します。この例の場合では `o_2_ncy_dem` と `o_3_nyc_dem` が作成されます。これは、データ表示に便利です。"

#: ../../en/rasters.rst:142
msgid "-I to create a spatial index"
msgstr "-I 空間インデックスを生成します"

#: ../../en/rasters.rst:143
msgid "`-F` to add file name, if you have only one tif file, this is kinda pointless. If you had multiple, this would be useful to tell you what file each row came from."
msgstr "`-F` ファイル名を追加します。単一の TIFF ファイルしかない場合には、これはちょっと無意味です。複数のファイルをロードする場合には、各行がどのファイルから来たデータかを知るのに便利です。"

#: ../../en/rasters.rst:145
msgid "`-t` to set the block size. Note if you are not sure the best size use, use `-t auto` instead and raster2pgql will use the same tiling as what was in the tif. The output will tell you what the blocksize is it chose. Cancel if it looks huge or weird. The original file had a size of 300x7 which is not ideal."
msgstr "`-t` ブロックサイズを指定します。使用サイズの最適値が分からない場合には、代わりに `-t auto` を使うと、raster2pgsql は TIFF ファイルと同じタイリングを使うことに注意して下さい。出力で、どのブロックサイズが選択されるかが分かります。巨大サイズになったり奇妙な値になる場合にはキャンセルして下さい。元のファイルのサイズは 300x7 ですが、理想的ではありません。"

#: ../../en/rasters.rst:149
msgid "Use :command:`psql` to run the generated sql against the database. If you want to dump to a file instead, use `> nyc_dem.sql`"
msgstr ":command:`psql` を使って、生成した SQL をデータベース上で実行します。そうでなくファイルにダンプしたい場合には `> nyc_dem.sql` を使います。"

#: ../../en/rasters.rst:153
msgid "For this example, we have only one tif file, so we could instead specify the full file name, instead of `*.tif`.  If the files are not in your current directory, you can also specify a folder path with `*.tif`."
msgstr "この例では、TIFF ファイルが一つしかないので、`*.tif` でなく、 完全なファイル名を指定できます。ファイルがカレントディレクトリに無い場合には、フォルダパスに `*.tif` を付けて指定することもできます。"

#: ../../en/rasters.rst:158
msgid "If you are on windows and need to reference the folder, make sure to include the drive letter such as `C:/workshop/*.tif`"
msgstr "Windows を使用していて、フォルダの参照が必要な場合には、`C:/workshop/*.tif` のように、ドライブレターを必ず含めて下さい。"

#: ../../en/rasters.rst:161
msgid "You'll often hear in PostGIS lingo, the term **raster tile** and **raster** used somewhat interchangeably. A raster tile really corresponds to a particular raster in a raster column which is a subset of a bigger raster, such as this NYC dem data we just loaded. This is because when rasters are loaded into PostGIS from big raster files, they chopped into many rows to make them manageable.  Each raster in each row then is a part of a bigger raster.  Each tile covers same size area denoted by the blocksize you specified. Rasters are sadly limited by the 1GB PostgreSQL `TOAST <https://www.postgresql.org/docs/current/storage-toast.html>`_ limit and also the slow process of detoasting and so we need to chop up in order to achieve decent performance or to even store them."
msgstr "PostGIS の専門用語で **ラスタタイル** と **ラスタ** を、いくぶん交換可能な語として聞くことがあると思います。ラスタタイルは本当は、今ロードしたニューヨーク市 DEMデータ のような大きなラスタのサブセットであるラスタカラム内の特定のラスタに対応するものです。これは、大きなラスタファイルからラスタが PostGIS にロードされる時に、このラスタを管理できるようにするために多数の行に切り刻まれるためです。それぞれの行のそれぞれのラスタは大きなラスタの一部です。それぞれのタイルは、指定したブロックサイズで示される同じサイズの領域をカバーします。悲しむべきことに、ラスタは PostgreSQL `TOAST <https://www.postgresql.org/docs/current/storage-toast.html>`_ の 1GB 制限にひっかかり、TOASTからの復元処理が遅いこともあり、適切なパフォーマンスの達成や保存のために、切り刻まなければなりません。"

#: ../../en/rasters.rst:170
msgid "Viewing Rasters in Browser"
msgstr "ブラウザでのラスタ表示"

#: ../../en/rasters.rst:171
msgid "Although pgAdmin and psql have no mechanism yet to view postgis rasters, we have a couple of options. For smallish rasters the easiest is to output to a web-friendly raster format such as PNG using batteries included postgis raster functions like `ST_AsPNG` or `ST_AsGDALRaster` listed in `PostGIS Raster output functions <https://postgis.net/docs/RT_reference.html#Raster_Outputs>`_. As your rasters get larger, you'll want to graduate to a tool such as QGIS to view them in all their glory or the GDAL family of commandline tools such as :command:`gdal_translate` to export them to other raster formats.  Remember though, postgis rasters are built for analysis, not for generating pretty pictures for you to look at."
msgstr "pgAdmin と psql は、PostGISラスタ を表示する機構を持っていませんが、二つの選択肢があります。小さめのラスタの場合には、`PostGIS ラスタ出力関数 <https://postgis.net/docs/ja/RT_reference.html#Raster_Outputs>`_ に出ている `ST_AsPNG` や `ST_AsGDALRaster` といったものを含む一連の PostGIS ラスタ関数を使って、PNG 等のウェブフレンドリなラスタフォーマットで出力するのが最も簡単です。ラスタが大きくなるにつれて、表示に非常によく使われている QGIS のようなツールを使うか、他のラスタフォーマットにエクスポートする :command:`gdal_translate` などの GDAL ファミリのコマンドラインツールを使うかに進むことになると思います。ただし、PostGIS ラスタは分析のために作られたものであって、見栄えのする画像を生成するためのものでないことは忘れないでください。"

#: ../../en/rasters.rst:178
msgid "One caveat, by default all different raster types outputs are disabled. In order to utilize these, you'll need to enable drivers, all or a subset as detailed in `Enable GDAL Raster drivers <https://postgis.net/docs/postgis_gdal_enabled_drivers.html>`_"
msgstr "デフォルトでは、全ての異なるラスタタイプの出力が無効になっていることに注意して下さい。利用可能にするには、ドライバの全てまたは一部を有効にする必要があります。詳細は `GDALラスタドライバの有効化 <https://postgis.net/docs/ja/postgis_gdal_enabled_drivers.html>`_ をご覧下さい。"

#: ../../en/rasters.rst:186
msgid "If you don't want to have to do this for each connection, you can set at the database level using:"
msgstr "データベースサーバへの接続のたびにこれを実行したくない場合には、次のようにするとデータベースレベルで設定できます:"

#: ../../en/rasters.rst:192
msgid "Each new connection to the database will use that setting."
msgstr "新規のデータベースへの接続では、この設定が使われます。"

#: ../../en/rasters.rst:194
msgid "Run the below query and copy and paste the output into the address bar of your web browser."
msgstr "下のクエリを実行して、出力をコピーしてブラウザのアドレスバーにペーストします。"

#: ../../en/rasters.rst:205
msgid "For the rasters created thus far, we didn't specify the number of bands nor did we even define their relation to earth.  As such our rasters have an unknown spatial reference system (0)."
msgstr "ここまでに作成されたラスタについては、バンド数を指定しませんし、地球との関係も定義しません。このため、ラスタが不明な空間参照系 (0) になります。"

#: ../../en/rasters.rst:208
msgid "You can think of a rasters exoskeletal as a geometry. A matrix encased in a geometric envelop. In order to do useful analysis, we need to georeference our rasters, meaning we want each pixel (rectangle) to represent some meaningful plot of space."
msgstr "ラスタの外骨格はジオメトリと考えることができます。ジオメトリのエンベロープに入ったマトリクスです。便利な分析を行うには、空間のプロットを表現するピクセル (矩形) が欲しいので、ラスタのジオリファレンスが必要です。"

#: ../../en/rasters.rst:213
msgid "The `ST_AsRaster` has many overloaded representations. The earlier example used the simplest such implementation and accepted the default arguments which are 8BUI and 1 band, with no data being 0. If you need to use the other variants, you should use the named arguments call syntax so that you don't accidentally fall into the wrong variant of the function or get **function is not unique** errors."
msgstr "`ST_AsRaster` は多数のオーバーロードを持ちます。前の例では、最も単純な実装を使い、 8BUI で 1 バンドのデフォルト引数を使い、NO DATA を 0 にしました。他の形式を使う必要がある場合には、名前付き引数による呼出し文法を使って、誤って思ってたものと違う形式を呼び出したり、**関数が一意でない**エラーが発生したりしないようにするべきです。"

#: ../../en/rasters.rst:221
msgid "If you start with a geometry that has a spatial reference system, you'll end up with a raster with same spatial reference system. In this next example, we'll plop our words in New York in bright cheery colors. We will also use pixel scale instead of width and height so that our raster pixel sizes represent 1 meter x 1 meter of space."
msgstr "空間参照系を持つジオメトリから開始する場合には、同じ空間参照系を持つラスタで終わります。この次の例では、明るく元気のある色の単語をニューヨークに落とします。幅と高さの代わりにピクセルスケールを使用して、ラスタのピクセルサイズが空間の 1メートル × 1メートル になるようにします。"

#: ../../en/rasters.rst:244
msgid "If we then look at this, we'll see a non-squashed colored geometry."
msgstr "これを見ると、押しつぶされていない色付きのジオメトリが見えます。"

#: ../../en/rasters.rst:255
msgid "Repeat for Raster:"
msgstr "Raster についても同じにします:"

#: ../../en/rasters.rst:266
msgid "What is more telling, if we rerun the"
msgstr "それ以上に、次を実行して"

#: ../../en/rasters.rst:273
msgid "Observe the metadata of the New York entries. They have the New York state plane meter spatial reference system. They also have the same scale.  Since each unit is 1x1 meter, the width of the word **Raster** is now wider than **Hello**."
msgstr "ニューヨークのエントリのメタデータを確認します。メートル単位のニューヨーク州平面の空間参照系を持っています。また、スケールも同じです。それぞれの単位は 1x1メートル ですので、**Raster** という単語の幅は **Hello** よりも広くなります。"

#: ../../en/rasters.rst:288
msgid "Raster Spatial Catalog tables"
msgstr "ラスタ空間カタログテーブル"

#: ../../en/rasters.rst:289
msgid "Similar to the geometry and geography types, raster has a set of catalogs that show you all raster columns in your database. These are `raster_columns and raster_overviews <https://postgis.net/docs/using_raster_dataman.html#RT_Raster_Catalog>`_."
msgstr "ジオメトリ型やジオグラフィ型と同じように、ラスタはデータベース内のすべてのラスタカラムを表示するカタログの集合を持っています。`raster_columns と raster_overviews <https://postgis.net/docs/ja/using_raster_dataman.html#RT_Raster_Catalog>`_ があります。"

#: ../../en/rasters.rst:295
msgid "raster_columns"
msgstr "raster_columns"

#: ../../en/rasters.rst:297
msgid "The `raster_columns` view to the sibling to the  `geometry_columns` and `geography_columns`, providing much the same data and more, but for raster columns."
msgstr "`raster_columns` は `geometry_columns` と `geography_columns` の兄弟のようなもので、同等以上のデータが提供されますが、ラスタカラム用です。"

#: ../../en/rasters.rst:305
msgid "Explore the table, and you'll find this:"
msgstr "テーブルを調べると、次のことが分かります:"

#: ../../en/rasters.rst:317
msgid "a disappointing row of largely unfilled information for the `rasters` table."
msgstr "`rasters` テーブルについては、ほんとどの情報が記入されていない残念な行になってしまっています。"

#: ../../en/rasters.rst:319
msgid "Unlike geometry and geography, raster does not support type modifiers, because type modifier space is too limited and there are more critical properties than what can fit in a type modifier."
msgstr "ジオメトリとジオグラフィと違い、ラスタは型修飾子に対応していません。型修飾子はスペースが限られ過ぎていて、型識別子に入るものよりも重要なプロパティがあります。"

#: ../../en/rasters.rst:322
msgid "Raster instead relies on constraints, and reads these constraints back as part of the view."
msgstr "ラスタは、そのかわりに制約に依存していて、これらの制約をビューの一部として読み取ります。"

#: ../../en/rasters.rst:324
msgid "Look at the other rows from the tables we loaded using :command:`raster2pgsql`. Because we used the `-C` switch :command:`raster2pgsql` added constraints for the srid and other info it was able to read from the tif or that we passed in. The overview tables generated with the `-l` switch `o_2_nyc_dem` and `o_3_nyc_dem` show up as well."
msgstr ":command:`raster2pgsql` を使ってロードしたテーブルの他の行を見て下さい。 `-C` スイッチをを使ったので、:command:`raster2pgsql` は、TIFF から読み取った情報や、ユーザが渡した情報によって、SRID の制約と他の情報を付加しました。`-l` で作られたオーバビューテーブル `o_2_nyc_dem` と `o_3_nyc_dem` も同じです。"

#: ../../en/rasters.rst:327
msgid "Let's try to add some constraints to our table."
msgstr "テーブルに制約を追加してみましょう。"

#: ../../en/rasters.rst:334
msgid "And you'll be bombarded with a whole bunch of notices about how your raster data is a mess and nothing can be constrained. If you look at raster_columns again, still the same disappointing story of many blank rows for `rasters`."
msgstr "そうすると、ラスタデータが混乱して何も制約できないという通知を大量に浴びます。raster_columns をもう一度見ると、`rasters` の行の多くが空のままと言う、さきほどと同じ残念な話のままになっています。"

#: ../../en/rasters.rst:338
msgid "In order for constraints to be applied, all rasters in your table must be constrainable by at least one rule."
msgstr "制約を適用するには、テーブルの全てのラスタが少なくとも一つの規則で制約できる必要があります。"

#: ../../en/rasters.rst:341
msgid "We can perhaps do this, let's just lie and say all our data is in New York State plane."
msgstr "これは可能かも知れません。嘘をついて、全てのデータがニューヨーク州平面座標系にあることにしましょう。"

#: ../../en/rasters.rst:355
msgid "Ah progress:"
msgstr "あ、進捗しましたね:"

#: ../../en/rasters.rst:364
msgid "The more you can constrain all your rasters, the more columns you'll see filled in and also the more operations you'll be able to do across all the tiles in your raster. Keep in mind that in some cases, you may not want to apply all constraints."
msgstr "制限できることが多いほど、値が入ったカラムの数が多くなり、ラスタ内のタイルの全てにおいて可能な操作も増えます。全ての制約を提供したくない場合もあることに注意して下さい。"

#: ../../en/rasters.rst:368
msgid "For example, if you plan to load more data into your raster table, you'll want to skip the extent constraint since that would require that all rasters are within the extent of the extent constraint."
msgstr "たとえば、ラスタテーブルにより多くのデータを入れ込む計画があったとします。範囲制約を設定すると、全てのラスタがその範囲内に存在する必要があるので、この制約を飛ばしたくなるでしょう。"

#: ../../en/rasters.rst:373
msgid "raster_overviews"
msgstr "raster_overviews"

#: ../../en/rasters.rst:374
msgid "Raster overview columns appear both in the `raster_columns` meta catalog and another meta catalog called `raster_overviews`. Overviews are used mostly to speed up viewing at higher zoom levels. They can also be used for quick back of the envelop analysis, providing less accurate stats, but at a much faster speed than applying to the raw raster table."
msgstr "ラスタオーバビューのカラムは `raster_columns` メタデータカタログ内と、他のメタデータカタログである `raster_overviews` 内との両方にあります。オーバビューは、たいていは高ズームレベル時の表示の速度向上に使われます。精度は低いけれども生のラスタテーブルに適用するよりずっと高速に統計情報を提供して、エンベロープ解析を素早く返すためにも使われます。"

#: ../../en/rasters.rst:379
msgid "To inspect the overviews, run:"
msgstr "オーバビューを調べるには次を実行します:"

#: ../../en/rasters.rst:386
msgid "and you'll see the output:"
msgstr "そすると、次のような出力が得られます:"

#: ../../en/rasters.rst:396
msgid "The `raster_overviews` table only provides you the overview_factor and the name of the parent table. All this information is something you could have figured out yourself by the `raster2pgsql` naming convention for overviews."
msgstr "`raster_overviews` テーブルは overview_factor と親テーブルの名前を提供しているだけです。この情報の全ては `raster2pgsql` のオーバビューに関する命名規則によって自分で考えられたはずです。"

#: ../../en/rasters.rst:400
msgid "The `overview_factor` tells you at what resolution the row is with respect to it's parent. An `overview_factor` of `2` means that 2x2 = 4 tiles can fit into one overview_2 tile. Similarly an overview_factor of `1` meants that 2x2x2 = 8 tiles of the original can be shoved into an overview_3 tile."
msgstr "`overview_factor` で、その行の親に対する解像度が分かります。`overview_factor` が `2` の場合には、2z2 = 4 タイルが、ひとつの overview_2 タイルに当てはまります。同様に `overview_factor` が `1` の場合には、overview_3 タイルに、元のタイルの 2x2x2 = 8 タイルが押し込まれます。"

#: ../../en/rasters.rst:407
msgid "Common Raster Functions"
msgstr "一般的なラスタ関数"

#: ../../en/rasters.rst:408
msgid "The :command:`postgis_raster` extension has over 100 functions to choose from. PostGIS raster functionality was patterned after the PostGIS geometry support. You'll find an overlap of functions between raster and geometry where it makes sense. Common ones you'll use that have equivalent in geometry world are :command:`ST_Intersects`, :command:`ST_SetSRID`, :command:`ST_SRID`, :command:`ST_Union`, :command:`ST_Intersection`, and :command:`ST_Transform`."
msgstr ":command:`postgis_raster` エクステンションは 100超 の関数から選択できます。PostGIS ラスタ機能は PostGIS ジオメトリ対応にならってパターン化されています。ラスタとジオメトリの間の関数の、意味のある重複があります。ジオメトリ世界で等価な関数で一般的なものとしては、:command:`ST_Intersects`, :command:`ST_SetSRID`, :command:`ST_SRID`, :command:`ST_Union`, :command:`ST_Intersection`, and :command:`ST_Transform` があります。"

#: ../../en/rasters.rst:415
msgid "In addition to those overlapping functions, it supports the `&&` overlap operator between rasters and between a raster and geometry. It also offers many functions that work in conjunction with geometry or are very specific to rasters."
msgstr "これらの重複する関数に加えて、ラスタ間やラスタとジオメトリ間で重複する `&&` 演算子があります。ジオメトリと連携して動作する関数やラスタに特化した関数なども多数用意されています。"

#: ../../en/rasters.rst:419
msgid "You need a function like :command:`ST_Union` to reconstitute a region. Because performance gets slow, the more pixels a function needs to analyse, you need a fast acting function :command:`ST_Clip` to clip the rasters to just the portions of interest for your analysis."
msgstr "領域の再構成として :command:`ST_Union` のような関数が必要になります。動作が遅くなるため、解析に必要なピクセルが増えるほど、ラスタを解析に必要な領域でのクリッピングで、動作速度を上げるための関数 :command:`ST_Clip` が必要になります。"

#: ../../en/rasters.rst:423
msgid "Finally you need :command:`ST_Intersects` or :command:`&&` to zoom in on the raster tiles that contain your areas of interest. The `&&` operator, is a faster process than the `ST_Intersects`. Both can take advantage of raster spatial indexes. We'll cover these bread and butter functions first before moving on to other sections where we will use them in concert with other raster and geometry functions."
msgstr "最後に、解析対象範囲を含むラスタタイルを拡大するには :command:`ST_Intersects` または :command:`&&` が必要です。`&&` 演算子の処理速度は `ST_Intersects`. より早いです。どちらもラスタ空間インデックスの利点を得ることができます。後のセクションでは、これらの基本関数と他のラスタ関数やジオメトリ関数とを併用しますが、そに移動する前に、これらの基本関数について説明します。"

#: ../../en/rasters.rst:429
msgid "Unioning Rasters with ST_Union"
msgstr "ST_Union によるラスタの結合"

#: ../../en/rasters.rst:430
msgid "The `ST_Union <https://postgis.net/docs/RT_ST_Union.html>`_ function for raster, just as the geometry equivalent :command:`ST_Union`, aggregates a set of rasters together into a single raster.  However, just as with geometry, not all rasters can be combined together, but the rules for raster unioning are more complicated than geometry rules. In the case of geometries, all you need is to have the same spatial reference system, but for rasters that is not sufficient."
msgstr "ラスタ用の `ST_Union <https://postgis.net/docs/ja/RT_ST_Union.html>`_ 関数は、ジオメトリ用 :command:`ST_Union` と同じで、ラスタの集合から単一ラスタに集約します。しかしながら、ジオメトリ用と同じで、全てのラスタを結合できるわけではありませんが、ラスタ結合の規則は、ジオメトリ結合の規則よりも複雑です。ジオメトリの場合には、必要なことは、同じ空間参照系であることだけですが、ラスタはそれだけでは不十分です。"

#: ../../en/rasters.rst:438
msgid "If you were to attempt, the following:"
msgstr "試そうとするなら次のようにします:"

#: ../../en/rasters.rst:445
msgid "You'd be summarily punished with an error:"
msgstr "簡潔に次のエラーの罰を受けることになります:"

#: ../../en/rasters.rst:447
msgid "**ERROR:  rt_raster_from_two_rasters: The two rasters provided do not have the same alignment SQL state: XX000**"
msgstr "**ERROR: rt_raster_from_two_rasters: The two rasters provided do not have the same alignment SQL state: XX000** (**エラー: rt_raster_from_two_rasters: 与えられた二つのラスタは同じアラインメントを持っていません SQL state: XX000**)"

#: ../../en/rasters.rst:450
msgid "What is this same alignment thing, that is preventing you from unioning your precious rasters?"
msgstr "この貴重なラスタとの結合を妨げる「同じアライメントのもの」というのは何ですか?"

#: ../../en/rasters.rst:452
msgid "In order for rasters to be combined, they need to be on the same grid so to speak. Meaning they must have same pixel sizes, same orientation (the skew), same spatial reference system, and their pixels must not cut into each other, meaning they share the same worldly pixel grid."
msgstr "ラスタを結合するには、言ってみれば、ラスタを同じグリッド上にあるようにする必要があります。つまり、同じピクセルサイズ、同じ向き (スキュー)、同じ空間参照系、同じピクセル数を持たなければなりません。また、ピクセルは互いに切り込んではなりません。これは、地球上で同じピクセルグリッドを共有してはならないということです。"

#: ../../en/rasters.rst:456
msgid "If you try the same query, but just with words we carefully placed in New York."
msgstr "同じクエリだけど、慎重にニューヨーク上に置くようにしたもので試してみます。"

#: ../../en/rasters.rst:458
msgid "Again, the same error. These are the same spatial ref system, the same pixel sizes, and yet it's still not good enough. Because their grids are off."
msgstr "また同じエラーが出ました。同じ空間参照系で、同じピクセルサイズなのに、それでも不十分なのです。グリッドがオフになっているためです。"

#: ../../en/rasters.rst:462
msgid "We can fix this by shifting the upper left y coordinates ever so slightly and then trying again. If our grids start at integer level since our pixel sizes are whole integer, then the pixels won't cut into each other."
msgstr "左上の座標をほんの少しずらしてから再度試してみます。ピクセルサイズが整数なのでグリッド開始位置が整数なら、ピクセルは互いに切り込んでしまうことはありません。"

#: ../../en/rasters.rst:477 ../../en/rasters.rst:526
msgid "Voila it worked, and if we were to view, we'd see something like this:"
msgstr "ほらほら、動きましたよ。次のようなものが表示されます:"

#: ../../en/rasters.rst:483
msgid "If ever you are unclear why your rasters don't have the same alignment, you can use the function `ST_SameAlignment <https://postgis.net/docs/RT_ST_SameAlignment.html>`_, which will compare 2 rasters or a set of rasters and tell you if they have the same alignment.  If you have notices enabled, the NOTICE will tell you what is off with the rasters in question. The `ST_NotSameAlignmentReason <https://postgis.net/docs/RT_ST_NotSameAlignmentReason.html>`_, instead of just a notice will output the reason. It however only works with two rasters at a time."
msgstr "ラスタが同じアラインメントにならない理由が不明な場合には、`ST_SameAlignment <https://postgis.net/docs/ja/RT_ST_SameAlignment.html>`_ が使えます。2個のラスタまたはラスタの集合を比較して、同じアラインメントを持つかどうかを教えてくれます。通知が有効なら、NOTICE で、問題のラスタの何がおかしいかを教えてくれます。`ST_NotSameAlignmentReason <https://postgis.net/docs/ja/RT_ST_NotSameAlignmentReason.html>`_ は、NOTICE の代わりとして、理由を出力してくれます。ただし、一度に2個のラスタでしか動作しません。"

#: ../../en/rasters.rst:490
msgid "One major way in which the `ST_Union(raster) <https://postgis.net/docs/RT_ST_Union.html>`_ raster function deviates from the `ST_Union(geometry) <https://postgis.net/docs/ST_Union.html>`_ geometry function is that it allows for an argument called *uniontype*.  This argument by default is set to `LAST` if you don't specify it, which means, take the **LAST** raster pixel values in occasions where the raster pixel values overlap. As a general rule, pixels in a band that are marked as no-data are ignored."
msgstr "`ST_Union(raster) <https://postgis.net/docs/ja/RT_ST_Union.html>`_ ラスタ関数が `ST_Union(geometry) <https://postgis.net/docs/ja/ST_Union.html>`_ ジオメトリ関数と大きく異なる点の一つとして、*uniontype* という引数が使用できることです。この引数は、指定していない場合のデフォルトでは `LAST` と設定されていて、ラスタのピクセル値がオーバラップする時は **最後の**ラスタピクセルを使います。一般的な規則として、NODATA になっているバンドのピクセルは無視されます。"

#: ../../en/rasters.rst:496
msgid "Just as with most aggregates in PostgreSQL, you can put a :command:`ORDER BY` clause as part of the function call as is done in the prior example.  Specifying the order, allows you to control which raster takes priority. So in our prior example, *Raster* trumped *Hello* because *Raster* is alphabetically last."
msgstr "PostgreSQL のほとんどの集約関数と同じで、前の例で行ったように、関数呼び出しの一部として :command:'ORDER BY'句 を配置できます。並び順を指定すると、どのラスターを優先するかを制御できます。そのため、前の例では *Raster* がアルファベット順で最後であるため、*Raster* が *Hello* より優先されました。"

#: ../../en/rasters.rst:500
msgid "Observe, if you switch the order:"
msgstr "注意して下さい。並び順を入れ替えると:"

#: ../../en/rasters.rst:510
msgid "Then *Hello* trumps *Raster* because Hello is now the last overlaid."
msgstr "*Hello* が *Raster* より優先されます。\"Hello\" が最後にオーバレイされるためです。"

#: ../../en/rasters.rst:512
msgid "The :command:`FIRST` union type is the reverse of :command:`LAST`."
msgstr ":command:`FIRST` 結合タイプは :command:`LAST` の逆です。"

#: ../../en/rasters.rst:514
msgid "But on occassion, **LAST** may not be the right operation. Let's suppose our rasters represented two different sets of observations from two different devices. These devices measure the same thing, and we aren't sure which is right when they cross paths, so we'd instead like to take the `MEAN` of the results.  We'd do this:"
msgstr "ただし、**LAST** は正しい操作とは限らないことがあります。ラスタが二つの異なる機材から二つの異なる観測を表現したと考えます。デバイスは同じものを計測して、パスが交差する時、どちらが正しいかが分からないので、代わりに結果の `MEAN` (平均値) を取りたくなります。次のようにします:"

#: ../../en/rasters.rst:530
msgid "So instead of trumping, we have a blending of the two forces. In the case of :command:`MEAN` union type, there is no point in specifying order, because the result would be the average of overlapping pixel values."
msgstr "どちらを優先するかを決めずに、二つを混ぜ合わせています。:command:`MEAN` 結合タイプの場合には、結果が重なり合うピクセル値の平均値を取るため、並び順を決定する意味がありません。"

#: ../../en/rasters.rst:534
msgid "Note that for geometries since geometries are vector and thus have no values besides there or not there, there really isn't any ambiguity on how to combine two vectors when they intersect."
msgstr "ジオメトリについては、ジオメトリはベクタなので、その地点にあるかないかの他に値がありません。このため、二つのベクタがインタセクトする時に、これらのベクタがどう結合するかに関して、あいまいな点はありません。"

#: ../../en/rasters.rst:538
msgid "Another feature of the raster :command:`ST_Union` we glossed over, is this idea of if you should return all bands or just some bands. When you don't specify what bands to union, :command:`ST_Union` will combine same banded numbers and use the :command:`LAST` unioning strategy.  If you have multiple bands, this may not be what you want to do. Perhaps you only want to union, the second band. In this case, the Green Band and you want the count of pixel values."
msgstr "ラスタ版の :command:`ST_Union` の隠していた機能として、全てのバンドを返すべきか、いくつかのバンドを返すべきかのアイデアです。どのバンドを結合するかを指定しない場合には、 :command:`ST_Union` は同じバンド番号同士を結合して、:command:`LAST` 結合戦略を採用します。複数のバンドがある場合には、これはやりたいことと違うようになるかもしれません。もしかしたら、結合したいというのが、2番目のバンドだけかもしれません。この場合には、緑バンドにピクセル数が必要です。"

#: ../../en/rasters.rst:559
msgid "Note in the case of the **COUNT** union type, which counts the number of pixels filled in and returns that value, the result is always a **32BUI** similar to how when you do a :command:`COUNT` in sql, the result is always a bigint, to accommodate large counts."
msgstr "**COUNT** 結合タイプの場合には、値の入っているピクセルをカウントして、その値を返します。結果は常に **32BUI** です。SQL で :command:`COUNT` を実行する時と同じです。結果は常に bigint型 で、大きな数のカウントに対応できます。"

#: ../../en/rasters.rst:563
msgid "In other cases, the band pixel type does not change and is set to the max value or rounded if the amounts exceed the bounds of the type. Why would anyone ever want to count pixels that intersect at a location. Well suppose each of your rasters represent police squadrons and incidents of arrests in the areas. Each value, might represent a different kind of arrest reason. You are doing stats on how many arrests in each region, therefore you only care about the count of arrests."
msgstr "その他の場合には、バンドのピクセルタイプは変更されず、値がタイプの境界を超えると、最大値または丸められた値になります。なぜ、ある場所でインタセクトするピクセル数を数えたいのでしょう。たとえば、警察小隊と逮捕事件とを表現するラスタがあるとします。ピクセルごとの値は、異なる逮捕理由を表現している可能性があります。しかし、今は地域ごとの逮捕の統計を作成しているところなので逮捕件数のみに注目しています。"

#: ../../en/rasters.rst:572
msgid "Or perhaps, you want to do all bands, but you want different strategies."
msgstr "もしくは、全てのバンドをやりたいけど、他の戦略が欲しい場合もあるかも知れません。"

#: ../../en/rasters.rst:582
msgid "Using the *unionarg[]* variant of the :command:`ST_Union` function, also allows you to shuffle the order of the bands."
msgstr ":command:`ST_Union` 関数の *unionarg[]* の形式を使ってもバンドの順序変更が可能です。"

#: ../../en/rasters.rst:585
msgid "Clipping Rasters with help of ST_Intersects"
msgstr "ラスタを ST_Intersects の助を得てクリッピングする"

#: ../../en/rasters.rst:586
msgid "The `ST_Clip <https://postgis.net/docs/RT_ST_Clip.html>`_ function is one of the most widely used functions for PostGIS rasters.  The main reason is the more pixels you need to inspect or do operations on, the slower your processing. **ST_Clip** clips your raster to just the area of interest, so you can isolate your operations to just that area."
msgstr "`ST_Clip <https://postgis.net/docs/ja/RT_ST_Clip.html>`_ 関数は、PostGISラスタ で最も幅広く使われる関数の一つです。主な理由としては、調査や操作が必要なピクセルが増えると、処理速度が落ちるためです。**ST_Clip** はラスタを必要な領域にクリップして、操作をその領域のみに分離できます。"

#: ../../en/rasters.rst:590
msgid "This function is also special in that it utilizes the power of geometry to help raster analysis. To reduce the number of pixels, :command:`ST_Union` has to handle, each raster is clipped first to the area we are interested in."
msgstr "この関数は、ジオメトリの能力を利用して、ラスタ分析を助けるという点においても特徴的です。ピクセル数を減らすために :command:`ST_Union` は、まずラスタごとに必要な領域にクリッピングするよう操作します。"

#: ../../en/rasters.rst:602
msgid "This example showcases several functions working in unison.  The :command:`ST_Intersects` function employed is the one packaged with **postgis_raster** and can intersect 2 rasters or a raster and a geometry. Similar to the geometry :command:`ST_Intersects` the `raster ST_Intersects <https://postgis.net/docs/RT_ST_Intersects.html>`_ can take advantage of spatial indexes on the raster or geometry tables."
msgstr "この例では、連携して動作するいくつかの関数を紹介しています。使われている :command:`ST_Intersects` 関数は **postgis_raster** でパッケージされている関数で、二つのラスタをインタセクトを見るか、一つのラストと一つのジオメトリとのインタセクトを見ることができます。ジオメトリ版 :command:`ST_Intersects` と同じで、`ラスタ版 ST_Intersects <https://postgis.net/docs/ja/RT_ST_Intersects.html>`_ は、ラスタテーブルやジオメトリテーブルにある空間インデックスの利点を利用できます。"

#: ../../en/rasters.rst:609
msgid "Converting Rasters to Geometries"
msgstr "ラスタのジオメトリへの変換"

#: ../../en/rasters.rst:610
msgid "Rasters can just as easily be morphed into geometries."
msgstr "ラスタはジオメトリに簡単に変換できます。"

#: ../../en/rasters.rst:613
msgid "The polygon of a raster with ST_Polygon"
msgstr "ST_Polygonのよるラスタのポリゴン"

#: ../../en/rasters.rst:614
msgid "Lets start with our prior example, but convert it to a polygon using `ST_Polygon <https://postgis.net/docs/RT_ST_Polygon.html>`_ function."
msgstr "前の例から始めます。ただし、<https://postgis.net/docs/ja/RT_ST_Polygon.html>`_ 関数を使ってポリゴンに変換します。"

#: ../../en/rasters.rst:625
msgid "If you click on the geometry viewer in pgAdmin, you can see this in all it's glory without any hacks."
msgstr "ここで pgAdmin のジオメトリビューアをクリックすると、何の特殊な操作もなく、これを見ることができます。素晴らしいですね。"

#: ../../en/rasters.rst:629
msgid ":command:`ST_Polygon` considers all the pixels that have values (not no-data) in a particular band, and converts them to geometry.  Like many other functions in raster, :command:`ST_Polygon` only considers 1 band. If no band is specified, it will consider only the first band."
msgstr ":command:`ST_Polygon` は、値を持つ (NODATA値になっていない) ピクセルの全てを考慮に入れて、ジオメトリに変換します。他の多くの関数のように、:command:`ST_Polygon` は 1バンド だけを対象にします。バンドが指定されていない場合には、最初のバンドだけを対象にします。"

#: ../../en/rasters.rst:634
msgid "The pixel rectangles of a raster with ST_PixelAsPolygons"
msgstr "ST_PixelAsPolygons によるラスタのピクセルの四角形"

#: ../../en/rasters.rst:635
msgid "Another popularly used function is the `ST_PixelAsPolygons <https://postgis.net/docs/RT_ST_PixelAsPolygons.html>`_ function. You should rarely use :command:`ST_PixelAsPolygons` on a large raster without first clipping because you will end up with millions of rows, one for each pixel."
msgstr "もう一つの良く使われる関数は `ST_PixelAsPolygons <https://postgis.net/docs/ja/RT_ST_PixelAsPolygons.html>`_ です。クリッピングを施さないままの大きなラスタに対して :command:`ST_PixelAsPolygons` をあまり使うべきではありません。ピクセルごとの行が数百万行できてしまうためです。"

#: ../../en/rasters.rst:638
msgid ":command:`ST_PixelAsPolygons` returns a table consisting of geom, val, x, and y. Where x is the column number, and y is the row number in the raster."
msgstr ":command:`ST_PixelAsPolygons` は geom, x, y からなるテーブルを返します。ここで、x がラスタのカラム番号、y が行番号です。"

#: ../../en/rasters.rst:641
msgid ":command:`ST_PixelAsPolygons` similar to other raster functions works on one band at a time and works on band 1 if no band is specified. It also by default returns only pixels that have values."
msgstr ":command:`ST_PixelAsPolygons` は、他の一度に 1バンド で動作するラスタ関数と似ていて、バンドが指定されていない場合には、1番バンド で動作します。デフォルトでは値を持つピクセルだけが返されます。"

#: ../../en/rasters.rst:653
msgid "Which outputs:"
msgstr "出力:"

#: ../../en/rasters.rst:657
msgid "and if we inspect using the geometry viewer, we'd see:"
msgstr "また、ジオメトリビューアを使って調べると、次のようになります:"

#: ../../en/rasters.rst:661
msgid "If we want all pixels of all our bands, we'd need to do something like below. Note the differences in this example from previous."
msgstr "バンドの全てのピクセルが必要な場合には、次のようなことを行う必要があります。この例は前のものと違うことに注意して下さい。"

#: ../../en/rasters.rst:664
msgid "1. Setting  :command:`exclude_nodata_value` to make sure all pixels are returned so that our sets of calls return the same number of rows. The rows out of the function will be naturally in the same order."
msgstr "1. :command:`exclude_nodata_value`を設定して、全てのピクセルが返されて、複数の関数呼び出しで同じ数の行が返るようにします。関数から出る行は当然、同じ順序になります。"

#: ../../en/rasters.rst:667
msgid "2. Using the `PostgreSQL ROWS FROM constructor <https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-TABLEFUNCTIONS>`_ , and aliasing each set of columns from our function output with names. So for example the band 1 columns (geom, val, x, y) are renamed to g1, v1, x1, x2"
msgstr "2. `PostgreSQL ROWS FROM構文 <https://www.postgresql.jp/document/current/html/queries-table-expressions.html#QUERIES-TABLEFUNCTIONS>`_ を使って、関数出力から列の集合に名前を付けます。たとえば、バンド 1 の列 (geom, val, x, y) を g1, v1, x2, x2 といった具合にです"

#: ../../en/rasters.rst:688
msgid "We used CROSS JOIN LATERAL in these examples because we wanted to be explicit what we are doing. Since these are all set returning functions, you can replace CROSS JOIN LATERAL with , for short-hand.  We'll use a , in the next set of examples"
msgstr "これらの例では、何をすべきか明示するため CROSS JOIN LATERAL を使っています。これらは返り値を返す全ての関数ですから、 CROSS JOIN LATERAL を \",\" の短縮形に置き換えられます。次の一群の例では \",\" を使います"

#: ../../en/rasters.rst:694
msgid "Dumping polygons with ST_DumpAsPolygons"
msgstr "ST_DumpAsPolygons でポリゴンをダンプする"

#: ../../en/rasters.rst:696
msgid "Raster also introduces an additional composite type called a :command:`geomval`. Consider a :command:`geomval` as the offspring of a geometry and raster. It contains a geometry and it contains a pixel value."
msgstr "ラスタは追加で :command:`geomval` と呼ばれる複合型の導入もしています。:command:`geomval` をジオメトリとラスタの子孫と考えて下さい。この型は、ジオメトリを含み、ピクセル値を含みます。"

#: ../../en/rasters.rst:700
msgid "You will find several raster functions that return geomvals."
msgstr "ラスタ関数には geomval を返すものが複数あります。"

#: ../../en/rasters.rst:702
msgid "A commonly used function that outputs geomvals is `ST_DumpAsPolygons <https://postgis.net/docs/RT_ST_DumpAsPolygons.html>`_, which returns a set of contiguous pixels with the same value as a polygon.  Again this by default will only check band 1 and exclude no data values unless you override. This example selects only polygons from band 2. You can also apply filters to the values. For most use cases, :command:`ST_DumpAsPolygons` is a better option than :command:`ST_PixelAsPolygons` as it will return far fewer rows."
msgstr "一般的に使用される geomval を返す関数に `ST_DumpAsPolygons <https://postgis.net/docs/ja/RT_ST_DumpAsPolygons.html>`_ があります。同じ値を持つ連続したピクセルの集合をポリゴンとして返します。また、デフォルトでは、オーバライドしない限り、バンド 1 をチェックするだけで、NODATA 値を排除しません。この例では、バンド 2 からのポリゴンだけを選んでいます。値へのフィルタの適用も可能です。ほとんどのユーズケースでは、:command:`ST_DumpAsPolygons` の方が、:command:`ST_PixelAsPolygons` よりも良い選択肢となります。返される行がはるかに少なくなるからです。"

#: ../../en/rasters.rst:707
msgid "This will output 6 rows, and return polygons corresponding to the letters in \"Raster\"."
msgstr "これは \"Raster\" という文字に対応するポリゴンを 6行 出力するものです。"

#: ../../en/rasters.rst:718
msgid "Note that it doesn't return a single geometry, because it finds continguous set of pixels with the same value that form a polygon. Even though all these values are the same, they are not continguous."
msgstr "この関数は、ポリゴンを形成する同じ値を持つ連続したピクセル集合を探すので、単一ジオメトリを返さないことに注意して下さい。全ての値が同じであっても、連続しているわけではありません。"

#: ../../en/rasters.rst:724
msgid "A common approach to produce more complex geometries is to group by the values and union."
msgstr "値でグループ化を行って結合するのが、より複雑なジオメトリを減らす一般的なアプローチです。"

#: ../../en/rasters.rst:734
msgid "This will give you 2 rows back corresponding to the words \"Raster\" and \"Hello\"."
msgstr "これで \"Raster\" と \"Hello\" の単語に対応する 2行 が返されます。"

#: ../../en/rasters.rst:737
msgid "Statistics"
msgstr "統計"

#: ../../en/rasters.rst:738
msgid "The most important thing to understand about rasters is that they are statistical tools for storing data in arrays, that you may happen to be able to make look pretty on a screen."
msgstr "ラスタに関する理解に最も重要なものは、ラスタは配列にデータを格納する統計ツールであることで、画面上で見栄えを良くすることができるのは、たまたまです。"

#: ../../en/rasters.rst:741
msgid "You can find a menu of these statistical functions in `Raster Band Statistics <https://postgis.net/docs/RT_reference.html#RasterBand_Stats>`_."
msgstr "統計関数の一覧は、`ラスタバンド統計情報と解析 <https://postgis.net/docs/ja/RT_reference.html#RasterBand_Stats>`_ にあります。"

#: ../../en/rasters.rst:745
msgid "ST_SummaryStatsAgg and ST_SummaryStats"
msgstr "ST_SummaryStatsAgg と ST_SummaryStats"

#: ../../en/rasters.rst:747
msgid "Want all stats for a set or rasters, reach for the function `ST_SummaryStatsAgg <https://postgis.net/docs/RT_ST_SummaryStatsAgg.html>`_."
msgstr "集合またはラスタの全ての統計処理が必要な場合には `ST_SummaryStatsAgg <https://postgis.net/docs/ja/RT_ST_SummaryStatsAgg.html>`_ に手を伸ばすことになります。"

#: ../../en/rasters.rst:749
msgid "This query takes about 10 seconds and gives you a summary of the whole table:"
msgstr "このクエリは約 10 秒かかり、テーブル全体の要約を表示します:"

#: ../../en/rasters.rst:756
msgid "Outputs:"
msgstr "出力:"

#: ../../en/rasters.rst:765
msgid "Which tells we have a lot of pixels and our max elevation is 411 ft."
msgstr "ここから、多数のピクセルがあり、最大標高が 411フィート であることが分かります。"

#: ../../en/rasters.rst:767
msgid "If you have built overviews, and just need a rough estimate of your mins, maxs, and means use one of your overviews. This next query returns roughly the same values for mins, maxs, and means as the prior but in about 1 second instead of 10."
msgstr "オーバビューを構築して、最大値、最小値、平均値の荒い見積もりが必要な場合には、オーバビューの一つを使用します。次のクエリは、前の結果と同じような最小値、最大値、平均値を荒く見積もりますが、10秒かかった計算を1秒で済みます。"

#: ../../en/rasters.rst:776
msgid "Now armed with this bit of information, we can ask more questions."
msgstr "この少しの情報から、さらなる質問が可能となります。"

#: ../../en/rasters.rst:779
msgid "ST_Histogram"
msgstr "ST_Histogram"

#: ../../en/rasters.rst:781
msgid "Generally you won't want stats for your whole table, but instead just stats for a particular area, in that case, you'll want to also employ our old friends :command:`ST_Intersects` and :command:`ST_Clip`. If you are also in need of a raster statistics function that doesn't have an aggregate version, you'll want to carry :command:`ST_Union` along for the ride."
msgstr "テーブル全体ではなく特定の領域の統計が必要となるのが一般的です。この場合には、古くからの友人である :command:`ST_Intersects` と :command:`ST_Clip` とを併用することになります。集約関数の形式を持たないラスタ統計関数も必要になる場合には、:command:`ST_Union` も仲間に入ってもらう必要があるでしょう。"

#: ../../en/rasters.rst:786
msgid "For this next example we'll use a different stats function `ST_Histogram <https://postgis.net/docs/RT_ST_Histogram.html>`_ which has no aggregate equivalent, and for this particular variant, is a set returning function. We are using the same area of interest as some prior examples, but we also need to employ geometry :command:`ST_Transform` to transform our NY state plane meters geometry to our NYC State Plane feet rasters.  It is almost always more performant to transform the geometry instead of raster and definitely if your geometry is just a single one."
msgstr "この次の例では、別の統計関数の ST_Histogram <https://postgis.net/docs/ja/RT_ST_Histogram.html>`_ を使います。これは、集約関数の形式を持っていなくて、特定の形式では集合を返します。前の例で必要とした領域と同じ領域を使いますが、ジオメトリ版 :command:`ST_Transform` でニューヨーク州平面メートルのジオメトリをニューヨーク州平面フィートのラスタに変換する必要もあります。ラスタでなくジオメトリを投影変換する方が、ほぼ常に変換性能がよくなり、ジオメトリが一つだけの場合には、間違いなく性能がよくなります。"

#: ../../en/rasters.rst:803
msgid "the above query completes in under 60ms and outputs:"
msgstr "上のクエリは60ミリ秒未満で終了し、次の出力を得ます。"

#: ../../en/rasters.rst:817
msgid "Creating Derivative Rasters"
msgstr "派生ラスタの生成"

#: ../../en/rasters.rst:818
msgid "PostGIS raster comes packaged with a number of functions for editing rasters. These functions are both used for editing as well as creating derivative raster data sets. You will find these listed in `Raster Editors <https://postgis.net/docs/RT_reference.html#Raster_Editors>`_ and `Raster Management <https://postgis.net/docs/RT_reference.html#Raster_Management_Functions>`_."
msgstr "PostGIS ラスタには多数のラスタ編集関数が梱包されています。これらの関数は編集にも派生ラスタデータセットの生成にも使えます。`ラスタエディタ <https://postgis.net/docs/ja/RT_reference.html#Raster_Editors>`_ と `ラスタ管理 <https://postgis.net/docs/ja/RT_reference.html#Raster_Management_Functions>`_ とのリストにあります。"

#: ../../en/rasters.rst:824
msgid "Transforming rasters with ST_Transform"
msgstr "ST_Transform によるラスタの座標変換"

#: ../../en/rasters.rst:825
msgid "Most of our data is in NY State Plane meters (SRID: 26918), however our DEM raster dataset is in NY State Plane feet (SRID: 2263). For the least cumbersome workflow, we need our core datasets to be in the same spatial reference system."
msgstr "使用しているデータのほとんどはニューヨーク州平面メートル (SRID: 26918) ですが、DEM ラスタデータセットはニューヨーク州平面フィート (SRID: 2263) です。面倒が最も少ないワークフローとして、中核データセットが同じ空間参照系上にあることが必要です。"

#: ../../en/rasters.rst:829
msgid "The `raster ST_Transform <https://postgis.net/docs/RT_ST_Transform.html>`_ is the function most suited for this job."
msgstr "`ラスタ版 ST_Transform <https://postgis.net/docs/ja/RT_ST_Transform.html>`_ はこの作業に最も適した関数です。"

#: ../../en/rasters.rst:831
msgid "In order to create a new nyc dem dataset in NY State Plane meters, we'll do the following:"
msgstr "ニューヨーク州平面メートルでの新しいニューヨーク市 DEM データセットを生成するために、次の操作を行います:"

#: ../../en/rasters.rst:841
msgid "The above on my system took about 1.5 minutes. For a larger data set it would take much longer."
msgstr "筆者のシステムでは 約1.5分 かかりました。より大きなデータセットでは、より長い時間がかかります。"

#: ../../en/rasters.rst:844
msgid "The aforementioned examples used two variants of the :command:`ST_Transform` raster function. The first was to get a reference raster that will be used to transform the other raster tiles to guarantee that all tiles have the same alignment.  Note the second variant of :command:`ST_Transform` used doesn't even take an input SRID. This is because the SRID and all the pixel scale and block sizes are read from the reference raster. If you used `ST_Transform(rast, srid)` form, then all your rasters might come out with different alignment making it impossible to apply an operation such as :command:`ST_Union` on them."
msgstr "前述の例ではラスタ版 :command:`ST_Transform` の二つの形式を使いました。一つ目は、全てのタイルが同じアラインメントを持つことを保証するために、他のラスタタイルを変換するために使用される参照ラスタを得ました。二つ目の :command:`ST_Transform` は、SRID と全てのピクセルの解像度とブロックサイズが参照ラスタから得るので、入力 SRID を引数に取らないことに注意して下さい。 `ST_Transform(rast, srid)` の形式を使った場合には、全てのラスタが異なるアラインメントで現れ、:command:`ST_Union` のような操作を適用できなくなる可能があります。"

#: ../../en/rasters.rst:851
msgid "The only problem with the aforementioned :command:`ST_Transform` approach is that when you transform, the transformed often exists in other tiles. If you looked at the above output closely enough by outputting the convex hull of the rasters, in the next example you'd see annoying overlaps around the borders."
msgstr "前述の :command:`ST_Transform` のアプローチの唯一の問題は、投影変換を実行する時に、変換されたものはしばしば他のタイル上に存在することになります。上の出力をラスタの凸包の出力で詳細に見ると、次の例では、境界まわりでオーバラップができて、イライラします。"

#: ../../en/rasters.rst:864
msgid "viewed in pgAdmin would look something like:"
msgstr "次に pgAdmin で見たものを示します:"

#: ../../en/rasters.rst:870
msgid "Using ST_MakeEmptyCoverage to create even tiled rasters"
msgstr "ST_MakeEmptyCoverage を使ってタイルラスタを作成する"

#: ../../en/rasters.rst:871
msgid "A better approach, albeit a bit slower, is to define your own coverage tile structure from scratch using `ST_MakeEmptyCoverage <https://postgis.net/docs/RT_ST_MakeEmptyCoverage.html>`_ and then find the intersecting tiles for each new tile, and ST_Union these and then use `ST_Transform(ref, ST_Union...)` to create each tile."
msgstr "少し遅くなりますが、より良いアプローチは、 'ST_MakeEmptyCoverage <https://postgis.net/docs/ja/RT_ST_MakeEmptyCoverage.html>'_を使用して独自のカバレッジタイル構造を最初から定義し、新しいタイルごとに交差するタイルを見つけ、これらを ST_Union してから 'ST_Transform(ref, ST_Union...)' を使用して各タイルを作成します。"

#: ../../en/rasters.rst:875
msgid "For this we'll be using quite a few functions, we learned about earlier."
msgstr "このため、以前に学習したかなりの数の関数を使用します。"

#: ../../en/rasters.rst:900
msgid "Repeating the same exercise as earlier:"
msgstr "前のと同じ演習を繰り返します:"

#: ../../en/rasters.rst:909
msgid "viewed in pgAdmin we no longer have overlaps:"
msgstr "ここで pgAdmin で見るとオーバラップがなくなりました:"

#: ../../en/rasters.rst:913
msgid "On my system this took ~10 minutes and returned 3879 rows. After the creation of the table, we'll want to do the usual of adding a spatial index, primary key, and constraints as follows:"
msgstr "筆者のシステムでは実行時間は 10分 未満ですみ、3879 行を返しました。テーブルの生成の後、通常の空間インデックス、主キー、制約を追加する作業を行うことになります。次のようにします:"

#: ../../en/rasters.rst:928
msgid "Which should take under 2 minutes for this dataset."
msgstr "このデータセットでは 2分 以内で済みます。"

#: ../../en/rasters.rst:931
msgid "Creating overview tables with ST_CreateOverview"
msgstr "ST_CreateOverview でオーバビューテーブルを作る"

#: ../../en/rasters.rst:933
msgid "Just as with our original dataset, it would be useful to have overview tables to speed up performance of some operations. `ST_CreateOverview <https://postgis.net/docs/RT_CreateOverview.html>`_ is a function fit for that purpose. You can use :command:`ST_CreateOverview` to create overviews also if you neglected to create one during the raster2pgsql load or  you decided, you need more overviews."
msgstr "元のデータセットと同じで、いくつかの処理の効率を良くするのにオーバビューテーブルがあると便利です。`ST_CreateOverview <https://postgis.net/docs/ja/RT_CreateOverview.html>`_ はこの目的に適した関数です。raster2pgsql のロード中にオーバビューを生成しなかった場合や、より多くのオーバビューが必要になった場合のオーバビュー生成にも :command:`ST_CreateOverview` を使うことができます。"

#: ../../en/rasters.rst:939
msgid "We'll create level 2 and 3 overviews as we had done with our original using this code."
msgstr "このコードを使って、元のデータに対して行ったように、レベル 2 とレベル 3 のオーバビューを作ります。"

#: ../../en/rasters.rst:946
msgid "This process sadly takes a while, and a longer while the more rows you have so be patient. For this dataset it took about 3-5 minutes for the overview factor `2` and 1 minute for the overview factor `3`."
msgstr "この処理は残念なことに時間がかかります。行が増えるほど長時間になるので辛抱して下さい。このデータセットで、オーバビュー係数が `2` で 約3-5分、`3` で 1分 かかりました。"

#: ../../en/rasters.rst:949
msgid "The :command:`ST_CreateOverView` function also adds in the needed constraints so the columns appear with full detail in the `raster_columns` and `raster_overviews` catalogs. It does not add indexes to them though and also does not add an rid column. The rid column is probably not necessary unless you need a primary key to edit with. You would probably want an index which you can create with the following:"
msgstr ":command:`ST_CreateOverView` 関数も必要な制限も追加するので、`raster_columns` と `raster_overviews` とのカタログ内に完全な詳細情報が付いたカラムが出現します。インデックスの追加は行わず、rid カラムも追加しません。rid カラムは、編集のために主キーが必要となるまでは、おそらく不要です。インデックスは多分必要になります。インデックスは次のようにして生成します:"

#: ../../en/rasters.rst:964
msgid "ST_CreateOverview has an optional argument for denoting the sampling method. If not specified it uses the default `NearestNeighbor` which is generally the fastest to compute but may not be ideal. Resampling methods is beyond the scope of this workshop."
msgstr "ST_CreateOverview には、サンプリング法を指定する任意引数があります。指定しない場合には、デフォルトで使われ、一般的に計算が最速ですが、理想的ではないことがある `最近傍` (`NearestNeighbor`) を使います。なお、リサンプリング法は本稿の範囲外です。"

#: ../../en/rasters.rst:970
msgid "The intersection of rasters and geometries"
msgstr "ラスタとジオメトリとのインタセクトした領域"

#: ../../en/rasters.rst:971
msgid "There are a couple of functions commonly used to compute intersections of rasters and geometries. We've already seen :command:`ST_Clip` in action which returns the intersection of a raster and geometry as a raster, but there are others. For point data, the most commonly used is :command:`ST_Value` and then there is the :command:`ST_Intersection` which has several overloads some returning rasters and some returning a set of `geomval`."
msgstr "ラスタとジオメトリのインタセクトした領域を計算するのに一般的に使われる二つの関数があります。ラスタとジオメトリのインタセクトした領域をラスタで返す :command:`ST_Clip` は既に見ていますが、もう一つあります。ポイントデータについては、最も一般的に使われるのが :command:`ST_Value` で、次に、ラスタを返したり `geomval` 集合を返したりと複数のオーバロードを持つ :command:`ST_Intersection` があります。"

#: ../../en/rasters.rst:979
msgid "Pixel values at a geometric Point"
msgstr "あるポイントジオメトリのピクセル値"

#: ../../en/rasters.rst:981
msgid "If you need to return values from rasters based on intersection of several ad-hoc geometry points, you'll use `ST_Value <https://postgis.net/docs/RT_ST_Value.html>`_ or it's nearest relative `ST_NearestValue <https://postgis.net/docs/RT_ST_NearestValue.html>`_."
msgstr "いくつかの特別なポイントジオメトリにインタセクトする場所に基づいて、ラスタから値を返す必要がある場合には、`ST_Value <https://postgis.net/docs/ja/RT_ST_Value.html>`_ を使うか、相対的に最近傍となる値を得る `ST_NearestValue <https://postgis.net/docs/ja/RT_ST_NearestValue.html>`_ を使います。"

#: ../../en/rasters.rst:995
msgid "This example takes about 1 second to return 2444 rows. If you used :command:`ST_Intersects` instead of :command:`&&`, the process would take about 3 seconds. The reason `ST_Intersects` is slower is that it performs an additional recheck in some cases a pixel by pixel check. If you expect all your points to be represented with data in your raster set and your rasters represent a coverage (a continguous set non-overlapping raster tiles), then `&&` is generally a speedier option."
msgstr "この例では、2444行 を返すのに 1秒 かかりました。:command:`&&` の代わりに :command:`ST_Intersects` を使った場合には、3秒 かかりました。`ST_Intersects` が遅いのは、ピクセルごとのチェックで追加の再チェックを行うためです。全てのポイントがラスタ集合のデータで表現され、ラスタがカバレッジ (オーバラップしないラスタタイルの連続的な集合) を表現することを期待する場合には、`&&` が一般的に速くなる選択肢です。"

#: ../../en/rasters.rst:1000
msgid "If your raster data is not densely populated or you have overlapping rasters (e.g. they represent different observations in time), or they are skewed (not axis aligned) then there is an advantage to having ST_Intersects weed out the false positives."
msgstr "ラスタデータが高密度でないか、ラスタがオーバラップしている (異なる観測結果を同時に表現している) か、スキューしている (軸に沿っていない) かのいずれかの場合には、ST_Intersects に誤検出を除かせるのは、利点があります。"

#: ../../en/rasters.rst:1006
msgid "ST_Intersection raster style"
msgstr "ST_Intersection ラスタスタイル"

#: ../../en/rasters.rst:1007
msgid "Just as you can compute the intersection of two geometries using :command:`ST_Intersection`, you can compute intersection of two rasters or a raster and a geometry using `raster ST_Intersection <https://postgis.net/docs/RT_ST_Intersection.html>`_."
msgstr ":command:`ST_Intersection` を使って、二つのジオメトリのインタセクトした領域を計算できるのと同じように、`ラスタ版 ST_Intersection <https://postgis.net/docs/ja/RT_ST_Intersection.html>`_ を使って、二つのラスタのインタセクトした領域を計算することができます。"

#: ../../en/rasters.rst:1011
msgid "What you get out of this beast, are two different kinds of things:"
msgstr "このケダモノから得られるのは、二つの異なる種類のものです:"

#: ../../en/rasters.rst:1013
msgid "Intersect a geometry with a raster, and you get a set of `geomval` offspring. Perhaps one, but most often many."
msgstr "ジオメトリとラスタとのインタセクトでは、`geomval` 結果の集合を得ます。一つの場合もありますが、ほとんどの場合が複数です。"

#: ../../en/rasters.rst:1016
msgid "Intersect 2 rasters and you get a single `raster` back."
msgstr "二つのラスタのインタセクトで、単一の `raster` が戻ります。"

#: ../../en/rasters.rst:1018
msgid "The golden rule for both raster intersection and geometry intersection is that both parties involved must have the same spatial reference system. For raster/raster, they also have to have same alignment."
msgstr "ラスタのインタセクトとジオメトリのインタセクトの両方で絶対的なルールとして、両方とも同じ空間参照系を持たなければならない、というものがあります。ラスタ対ラスタでは、そのうえ、同じアラインメントを持つ必要もあります。"

#: ../../en/rasters.rst:1022
msgid "Here is an example which answers a question you may have been curious about. If we bucket our elevations into 5 buckets of elevation values, which elevation range results in the most gun fatalities? We know based on our earlier summary statistics that `0` is the lowest value and `411` is the highest value for elevation in our nyc dem dataset, so we use that as min and max value for our `width_bucket <https://www.postgresql.org/docs/current/functions-math.html>`_ call."
msgstr "みなさんが興味を持つかもしれない質問に答える例があります。標高データを 5個 の区分に分けると、どの標高範囲が、銃による死者数が最多でしょうか? 前の統計の要約から、ニューヨーク市の標高データセットの最低値が `0` で最高値が `411` というのを知っているので、`width_bucket <https://www.postgresql.jp/document/current/html/functions-math.html>`_ 関数の呼出しのための最小値と最大値に使うことができます。"

#: ../../en/rasters.rst:1045
msgid "Is there an important correlation between gun homicides and elevation? Probably not."
msgstr "殺人事件と標高との間に重要な相関があるでしょうか? おそらくありません。"

#: ../../en/rasters.rst:1049
msgid "Let's take a look at raster / raster intersection:"
msgstr "ラスタ / ラスタ のインタセクト領域を見てみましょう:"

#: ../../en/rasters.rst:1058
msgid "What we get are two rows with NULLLs, and if you have your PostgreSQL set to show notices, you'll see:"
msgstr "得られたのは NULL を含む二つの行です。PostgreSQL に NOTICE を設定すると、次のようになります:"

#: ../../en/rasters.rst:1060
msgid "**NOTICE:  The two rasters provided do not have the same alignment.  Returning NULL**"
msgstr "**NOTICE: The two rasters provided do not have the same alignment. Returning NULL** (二つの与えられたラスタは同じアラインメントではありません。NULLを返します)"

#: ../../en/rasters.rst:1062
msgid "In order to fix this, we can align one to the other as it's coming out of the gate using `ST_Resample <https://postgis.net/docs/RT_ST_Resample.html>`_."
msgstr "これを修正するために、`ST_Resample <https://postgis.net/docs/ja/RT_ST_Resample.html>`_ を使って、一方のラスタをもう一方のラスタに揃えることができます。"

#: ../../en/rasters.rst:1074
msgid "Let's also roll it up into a single stats record"
msgstr "これを一つの統計レコードにまとめましょう"

#: ../../en/rasters.rst:1088
msgid "which outputs:"
msgstr "出力は次の通りです:"

#: ../../en/rasters.rst:1099
msgid "Map Algebra Functions"
msgstr "地図代数関数"

#: ../../en/rasters.rst:1100
msgid "Map algebra is the idea that you can do math on your pixel values. The :command:`ST_Union` and :command:`ST_Intersection` functions covered earlier are a special fast case of map algebra. Then there are the `ST_MapAlgebra <https://postgis.net/docs/RT_ST_Polygon.html>`_ family of functions which allow you to define your own crazy math, but at cost of performance."
msgstr "地図代数は、ピクセル値に対して計算を行うことができるという考えです。前に説明した :command:`ST_Union` 関数と :command:`ST_Intersection` 関数は、地図代数の特に高速なケースです。ご自身のすごい数学の定義が可能になりますが能率が犠牲になる `ST_MapAlgebra <https://postgis.net/docs/ja/RT_ST_Polygon.html>`_ 関数ファミリがあります。"

#: ../../en/rasters.rst:1108
msgid "People have the habit of jumping to  :command:`ST_MapAlgebra`, probably cause the name sounds so cool and sophisticated. Who wouldn't want to tell their friends, \"I'm using a function called ST_MapAlgebra.\" My advice, explore other functions before you jump for that shot-gun. Your life will be simpler and your performance will be 100 times better, and your code will be shorter."
msgstr "一般に :command:`ST_MapAlgebra` に飛びつきがちですが、これは、名前の聞こえが良くて、洗練されているように感じるからなのでしょう。「ST_MapAlgebra という関数を使ってるよ」と言いたくない人はいないでしょう。筆者のアドバイスとしては、早まったことをする前に、他の関数も調査して下さい。あなたの人生がよりシンプルになり、あなたの能率が 100倍 良くなりますし、あなたのコードが短くなります。"

#: ../../en/rasters.rst:1114
msgid "Before we showcase `ST_MapAlgebra`, we'll explore other functions that fit under the `Map Algebra` family of functions and generally have better performance than `ST_MapAlgebra`."
msgstr "`ST_MapAlgebra` を紹介する前に、`地図代数` (`Map Algebra`) 関数ファミリに該当して、一般的に `ST_MapAlgebra` より能率的な他の関数を調べます。"

#: ../../en/rasters.rst:1118
msgid "Reclassify your raster using ST_Reclass"
msgstr "ST_Reclass を使ったラスタの再分類"

#: ../../en/rasters.rst:1120
msgid "An often overlooked map-algebraish function is the `ST_Reclass <https://postgis.net/docs/RT_ST_Reclass.html>`_ function, who sits in the background waiting for someone to discover the power and speed it can offer."
msgstr "見落とされがちな地図代数関数に `ST_Reclass <https://postgis.net/docs/ja/RT_ST_Reclass.html>`_ があります。この関数は、物陰に隠れて、その秘めた能力と速度を見出してくれる人を待っています。"

#: ../../en/rasters.rst:1124
msgid "What does **ST_Reclass** do? It as the name implies, reclassifies your pixel values based on minimalist range algebra."
msgstr "**ST_Reclass** は何をするのでしょう? 名前が示すように、最小範囲の計算に基づいてピクセル値を再分類します。"

#: ../../en/rasters.rst:1126
msgid "Lets revisit our NYC Dems.  Perhaps we only care about classifying our elevations as 1) low, 2) medium, 3) high , and 4) really high. We don't need 411 values, we just need 4.  With that said lets do some reclassifying."
msgstr "ニューヨーク市のデモをもう一度見てみましょう。おそらく、標高が 1) 低い、2) 中間、3) 高い、4) 非常に高い、に分類することだけに気を配ることになります。411種 の値までは不要で、4種 で充分です。そんなわけで再分類をやってみましょう。"

#: ../../en/rasters.rst:1129
msgid "The classification scheme is governed by the `reclass expression <https://postgis.net/docs/reclassarg.html>`_."
msgstr "分類方式は `再分類式 <https://postgis.net/docs/ja/reclassarg.html>`_ で制御します。"

#: ../../en/rasters.rst:1145
msgid "Which would output:"
msgstr "出力は次のようになります:"

#: ../../en/rasters.rst:1157
msgid "If this were a classification scheme we preferred, we could create a new table using the ST_Reclass to recompute each tile."
msgstr "これが望ましい分類方式であるなら、ST_Reclass を使って各タイルを再計算して、新しいテーブルを作ることができることになります。"

#: ../../en/rasters.rst:1160
msgid "Coloring your rasters with ST_ColorMap"
msgstr "ST_ColorMap でラスタに色を付ける"

#: ../../en/rasters.rst:1161
msgid "The `ST_ColorMap <https://postgis.net/docs/RT_ST_ColorMap.html>`_ function is another mapalgebraish function that reclassifies your pixel values.  Except it is band creating. It converts a single band raster such as our Dems into a visually presentable 3 or 4 banded raster."
msgstr "`ST_ColorMap <https://postgis.net/docs/ja/RT_ST_ColorMap.html>`_ 関数は、ピクセル値を再分類する地図代数関数のひとつです。ただし、この関数ではバンドが生成されます。DEM のような単一バンドのラスタを視覚的に表現できる 3バンド か 4バンド のラスタに変換します。"

#: ../../en/rasters.rst:1165
msgid "You could use one of the built-in colormaps as below if you don't want to fuss with creating one."
msgstr "カラーマップの作成に手間を掛けたくない場合には、次のように組込カラーマップを使うことができます。"

#: ../../en/rasters.rst:1178
msgid "Which looks like:"
msgstr "次のようになります:"

#: ../../en/rasters.rst:1182
msgid "The bluer the color the lower the elevation and the redder the color the higher the elevation."
msgstr "色が青いほど標高が低く、色が赤いほど標高が高くなっています。"
