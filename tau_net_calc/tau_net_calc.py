
# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TAUNetCalc
                                 A QGIS plugin
 Accessibility Calculations
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-06-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Evgeny Kleiman
        email                : evgenykleiman@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QDir, Qt
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction,QFileDialog
from qgis.core import QgsProject, QgsVectorLayer, QgsWkbTypes, QgsPointXY, QgsSpatialIndex, QgsGeometry, QgsPointXY
from qgis.utils import iface
from PyQt5.QtWidgets import QApplication

from pyproj import Proj, transform

from PyQt5.QtWidgets import QApplication, QWidget, QRadioButton, QVBoxLayout
from functools import partial

from functools import partial
from .shortest_paths_utils import main_shortest_paths_utils
from datetime import datetime, date, timedelta

from .resources import *

from .tau_net_calc_dialog import TAUNetCalcDialog
from .tau_net_calc_settings_dialog import TAUNetSettingsCalcDialog

from .map_tools import SendPointToolCoordinates
from .spatial_queries import SpatialQueries, get_dist_time

import sys
import os

# # Get the current directory
current_dir = os.path.dirname(os.path.abspath(__file__))

# # Get the relative path to the module
module_path = os.path.join(current_dir, 'MYTRANSIT')
utils_path = os.path.join(current_dir, 'utils')
# # Add the relative path to sys.path
sys.path.append(module_path)
sys.path.append(utils_path)

#from query_file import mainQueryFile,getAccessedStopsByLabels, run_raptor_with_statistics 
from query_file import compareMethods, runRaptorWithProtocol 
from PKL import PKL_class

class TAUNetCalc():
    """QGIS Plugin Implementation."""
    stops_id_name = "stop_id"
    stops_build_name = "osm_id"
    stopsFile = "stops.txt"
    stopsLayerName = "stops"
          
     
    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'TAUNetCalc_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&TAU Network Calculator')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        
        self.settings = {
          "MaxWalkDist1":"",
          "MaxWalkDist2":"",
          "MaxWalkDist3":"",
          "MaxWaitTime":"",
          "MaxTimeTravel":"",


          "PathToNetwork":"",
          "PathToProtocols":"",
          "NETWORK_NAME":"",
          "MAX_TRANSFER":"",
          "WALKING_FROM_SOURCE":"",
          "D_TIME":"",          
          "CHANGE_TIME_SEC":"",
          "VELOCITY":"",
          "stopTolerance":"",           
          "ExactTransfersCount":0,
          "path_to_roads_layer":"",
          "path_to_stop_layer":"",
          

       }
        self.pointCase = 1 # 1: source point, 2: destination point
        self.raptormode = {        
          1:"right_raptor",
          2:"rev_raptor"
        }

        
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('TAUNetCalc', message)

    
    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag = True,
        add_to_menu = True,
        add_to_toolbar = True,
        status_tip = None,
        whats_this = None,
        parent = None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/tau_net_calc/icon.png'
        icon_settings_path = ':/plugins/tau_net_calc/settings.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Accessibility calculations'),
            callback=self.run,
            parent=self.iface.mainWindow())
        self.add_action(
            icon_settings_path,
            text=self.tr(u'Settings'),
            callback=self.runSettings,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
        self.first_start_settings = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&TAU Network Calculator'),
                action)
            self.iface.removeToolBarIcon(action)
    """
      Settings Dialog functions
    """
    def showProtocolDialog(self):        
      folder_path = QFileDialog.getExistingDirectory(self.dlg2, "Select Folder")
      self.dlg2.txtPathToProtocos.setText(folder_path)  
      
      

    def showGTFSDialog(self):        
      folder_path = QFileDialog.getExistingDirectory(self.dlg2, "Select Folder")
      self.dlg2.lineEdit.setText(folder_path)  
      
      #if not self.check_file_in_directory(folder_path, self.stopsFile):
      # #QMessageBox.about(self.dlg, "Warning", "This directory does not contain stops file")
      # self.dlg2.lblMessages.setText("This directory does not contain stops file")   
    
    """
    def check_file_in_directory(self,directory_path, file_name):
     dir = QDir(directory_path)
     file_path = dir.filePath(file_name)
     return dir.exists(file_name)
    
    def loadGTFS(self):
      folder_path = self.dlg2.lineEdit.text()
      #print("folder_path="+folder_path)
      if folder_path:
       #uri='file:///' + folder_path + '/'+ self.stopsFile + '?crs=EPSG:4326&delimiter=,&yField=stop_lat&xField=stop_lon'       
       uri = f'file:///{folder_path}/{self.stopsFile}?type=csv&maxFields=10000&detectTypes=yes&' \
             f'xField=stop_lon&yField=stop_lat&crs=EPSG:4326&spatialIndex=no&subsetIndex=no&watchFile=no'
       
       print (f'!uri = {uri}')
       layer = QgsVectorLayer(uri, 'stops', 'delimitedtext')
       QgsProject.instance().addMapLayer(layer)
       self.dlg2.lblMessages.setText("")
      else:
        #QMessageBox.information(None, "DEBUG:", "Path to GTFS folder is not defined")  
        #QgsMessageLog.logMessage("Path to GTFS folder is not defined")
        self.dlg2.lblMessages.setText("Path to GTFS folder is not defined")

    def loadShapes(self):
      folder_path = self.dlg2.lineEdit.text()
      
      layer = QgsVectorLayer(folder_path+"/shape/routesNamed.shp", "Routes", "ogr")
      #print(folder_path+"/shapes/shapefile.shp")
      try:
       QgsProject.instance().addMapLayer(layer)
      except Exception as e:
        print("Error:", str(e))
      if layer.isValid():
        print("Shapefile layer added successfully.")
      else:
       print("Failed to add shapefile layer.")
    """
    def getSettings(self):      
       self.saveParameters()
       self.readParameters()
       self.dlg2.accept()
       try:
        self.setLabelText() 
       except:
         pass

    def cancelSettings(self):       
       self.dlg2.done(0)   
    
    """
     Main window functions
    """
    """
     This function works when the plugin is starting.
     It gets all layers names from the map and shows them in combo box
     Then it makes name :stops" as the selected item of the combo
    """
    def get_layer_path_by_name(self,layer_name):
     layer = QgsProject.instance().mapLayersByName(layer_name)[0]
     layer_path = layer.dataProvider().dataSourceUri()
     return layer_path
    
    def AllLayersInCombo (self, cmb, names):
      for name in names:
          cmb.addItem(name, [])       
      index = cmb.findText(self.stopsLayerName, QtCore.Qt.MatchFixedString)
      if index >= 0:
        cmb.setCurrentIndex(index)

    def showAllLayersInCombo(self):
        names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]    
        cmb = self.dlg.cmbLayers       
        self.AllLayersInCombo (cmb, names)
        cmb = self.dlg.cmbLayers_2
        self.AllLayersInCombo (cmb, names)
        cmb = self.dlg.cmbLayers_4
        self.AllLayersInCombo (cmb, names)
        
    # Функция отображает в форме информацию о значении поля stopTolerance для source и destination
    # Также заполняет значение метки lblRadius
    # The function displays in the form information about the value of the stopTolerance field for source and destination
    # Also fills in the lblRadius label value
    def setLabelText (self):
      message_tolerance = f"Radius = {self.settings['stopTolerance']} m"
      self.dlg.lblTolerance1.setText(message_tolerance)
       
    
    def getSpeed(self): 
      #speed = int(self.settings["VELOCITY"] )
      speed = 1
    
      return speed

    
    
    def fillProtocolTypeCombo(self)     :
      cmb=self.dlg.cmbProtocolType
      cmb.addItem("summary statistics", 1) 
      cmb.addItem("detail statistics", 2)
      #cmb.addItem("board-arrive_protocol", 3)
      cmb.setCurrentIndex(1)

    def get_nearest_feature_from_layer (self, layer, lon, lat, limit):
      
      #point = QgsGeometry.fromPointXY(QgsPointXY(35.0016680, 32.8064413))
      point = QgsGeometry.fromPointXY(QgsPointXY(lat, lon))

      layer = QgsProject.instance().mapLayersByName(layer)[0] 
      try:
        spatial_index = QgsSpatialIndex(layer.getFeatures())
      except:
        self.setMessage(f'No features in layer {layer}')
        return 0 

      radius = 15000
      nearest_ids = spatial_index.nearestNeighbor(point, limit, radius)
      #print (f'nearest_ids {nearest_ids}')
      ids = []
      
      feature1 = layer.getFeature(nearest_ids[0])
      feature_geometry = feature1.geometry()

      if (feature_geometry.type() != QgsWkbTypes.PointGeometry and feature_geometry.type() != QgsWkbTypes.PolygonGeometry):
        self.setMessage("Layer not consist point and polygon")
        return 0   
     
      if feature_geometry.type() == QgsWkbTypes.PolygonGeometry:
        feature_id_field = self.stops_build_name

      if feature_geometry.type() == QgsWkbTypes.PointGeometry:
        feature_id_field = self.stops_id_name

      
      
      for feature_id in nearest_ids:
      
        feature = layer.getFeature(feature_id)
        id = feature[feature_id_field]  
        ids.append(int(id))

      #print (f' ids = {ids}')      
      return ids

      """
      print (f'lon= {lon} lat = {lat}' )
      print (f'layer= {layer} ' )
      
      #point = QgsGeometry.fromPointXY(QgsPointXY(lon, lat))
      point = QgsGeometry.fromPointXY(QgsPointXY(35.0016680, 32.8064413))
     
      layer = QgsProject.instance().mapLayersByName(layer)[0] 

      print (f'layer= {layer} ' )

      spatial_index = QgsSpatialIndex(layer.getFeatures())
      radius = 15000
      nearest_ids = spatial_index.nearestNeighbor(point, limit, radius)

      print (f'nearest_ids {nearest_ids}')
      ids = []

      
      feature_geometry = nearest_ids[0].geometry()
     
      if feature_geometry.type() == QgsWkbTypes.PolygonGeometry:
        feature_id_field = self.stops_build_name

      if feature_geometry.type() == QgsWkbTypes.PointGeometry:
        feature_id_field = self.stops_id_name 
      

      for feature_id in nearest_ids:
        
        #feature = layer.getFeature(feature_id)
        #id = feature[feature_id_field]  
        #ids.append(int(id))
        ids.append(int(feature_id))
           
      return ids
      """ 
    def setMessage (self, message):
      self.dlg.lblMessages.setText(message)

    def get_feature_from_layer (self, layer, limit = 0):
      layer = QgsProject.instance().mapLayersByName(layer)[0] 
      ids = []
      count = 0

      try:
        features = layer.getFeatures()
      except:
        self.setMessage(f'No features in layer {layer}')
        return 0  


      for feature in features:
        feature_geometry = feature.geometry()
        feature_geometry_type = feature_geometry.type()
        if feature_geometry_type == QgsWkbTypes.PolygonGeometry:
          feature_id_field = self.stops_build_name
        if feature_geometry_type == QgsWkbTypes.PointGeometry:
          feature_id_field = self.stops_id_name
        break  

 

      if (feature_geometry_type != QgsWkbTypes.PointGeometry and feature_geometry_type != QgsWkbTypes.PolygonGeometry):
        self.setMessage("Layer not consist point and polygon")
        return 0  
          

      for feature in features:
        count += 1
        
        id = feature[feature_id_field]  
        ids.append(int(id))  

        if count >= limit and limit != 0:
          break
      return ids
      
    
    """
    This function works as handler of btnSourcePoint (case 1) or btnDestPoint click (case 2)
    The goal: to get active layer and mapCanvas from the map and to prepare
    to get coordinates from the map when an user click in some place.
    This function uses class SendPointToolCoordinates that accepts 
    the canvas ,the layer and the callback function getCoords
    This callback function works after click on the map and gets x,y of the clicj
    """
    def getMapPoint(self,case):
       #print("case="+str(case))
       layer, canvas = iface.activeLayer(), iface.mapCanvas()
       self.pointCase = case
       send_point_tool_coordinates = SendPointToolCoordinates(
            canvas,
            layer,
            self.getCoords   # self.dlg
        )
       canvas.setMapTool(send_point_tool_coordinates)

    #This is callback function for getMapPoint function
    def getCoords(self,x,y):
     
      #point1 = (x, y)
      # Преобразование метрических координат в градусы
      # Convert metrs system to gradus system for calculate dist
      #utm_projection = Proj(init='epsg:2039')  
      #if x > 180 or y > 180:
      #  print ("transform!")
      #  x, y = transform(utm_projection, Proj(init='epsg:4326'), point1[0], point1[1])

      if self.pointCase == 1:
           self.dlg.txtLat.setText(str(round(x,5)))
           self.dlg.txtLon.setText(str(round(y,5)))
      else:
           self.dlg.txtLat_3.setText(str(round(x,5)))
           self.dlg.txtLon_3.setText(str(round(y,5)))    
     # a reference to our map canvas

    # def return array StopID from selected_layerName.
    # this use for filtering dict_stop_id
          
    

    def getStopID_array(self, settings, selected_layerName):
      sep=","
      layer = QgsProject.instance().mapLayersByName(selected_layerName) [0]
      res = []
      for f in layer.getFeatures():
       res.append(int(f['stop_id']))

      
      return res

    """
    This function is called when we need to found all features around a point
    Input: 
    - layer name according to current selected item in combo cmbLayers 
    - layers: all layers of the map
    - self.pointCase: 1 if btnSourcePoint was clicked, 2 - if btnDestPoint was clicked
    - txtLon,txtLat or txtLonDest,txtLatDest
    -  radius= float(self.settings["stopTolerance"])        
    Algorithm:
     - find layer in layers according layer name
     - get point =(xCenter,yCenter) from text boxes
     - make spatial query according the point and the radius getting features
     - for each feature add its id and data to combo box
     -  cmbResultsByCircle (source) or cmbResultsDestByCircle
    """  
     
    def getFeaturesByBuffer(self):
     
      if self.dlg.txtLon.text() == "" or self.dlg.txtLat.text() == "":
        self.dlg.lblMessages.setText("Need choice point on map")
        return 0

      layerName = self.dlg.cmbLayers.currentText()
      layers = QgsProject.instance().mapLayersByName(layerName)
      layer = layers[0]
      cmb = self.dlg.cmbResultsByCircle

      
      yCenter = float(self.dlg.txtLon.text())
      xCenter = float(self.dlg.txtLat.text())
                   
      radius = float(self.settings["stopTolerance"])  
      queries = SpatialQueries(layer)
      
      try:
        if xCenter > 180 or yCenter > 180: # metrs
          print ('metrs')
          features = queries.selectFromLayerBycircle(xCenter,yCenter,radius) 
        else:  # grad
          print ('grad')
          radDegrees = queries.metersToDecimalDegrees(radius,yCenter)
          features = queries.selectFromLayerBycircle(xCenter,yCenter,radDegrees) 
      except:
        cmb.clear() 
        self.setMessage("Layer not consist point and polygon")
        return 0

      
      cmb.clear()   
      speed = self.getSpeed()    
      for feature in features:
        feature_geometry = feature.geometry()

        if feature_geometry.type() != QgsWkbTypes.PointGeometry and feature_geometry.type() != QgsWkbTypes.PolygonGeometry:
          cmb.clear() 
          self.setMessage("Layer not consist point and polygon")
          return 0


        if feature_geometry.type() == QgsWkbTypes.PolygonGeometry:
          
          feature_id_field = self.stops_build_name
          centroid_point = feature_geometry.centroid().asPoint()
          lon = centroid_point.x()
          lat = centroid_point.y()
          id = feature["osm_id"]
          name = feature["name"]
          
        if feature_geometry.type() == QgsWkbTypes.PointGeometry:
                    
          feature_id_field = self.stops_id_name 
          coordinates = [feature_geometry.asPoint()]
          point_coordinates = coordinates[0]
          lon = point_coordinates[0]  # X-coordinate
          lat = point_coordinates[1]  # Y-coordinate
          
          id = feature["stop_id"]
          name = feature["stop_name"]
        dist,to_pdash_time = get_dist_time(speed, xCenter, yCenter,lon,lat)
        to_pdash_time = timedelta(seconds=round(to_pdash_time))

        name_stop = f'{id} {name} dist={dist:.1f}m time={to_pdash_time}' 
        cmb.addItem(name_stop, [feature[feature_id_field]])
      if cmb.count() == 0:
       self.dlg.lblMessages.setText("Not found feature near this point")
      else: 
       self.dlg.lblMessages.setText(f'Founded {cmb.count()} points')  

        
    def getCurrentItemFromCombo(self,cmb):
       ind = cmb.currentIndex()
       result = ""
       if ind >= 0:
          result = cmb.itemData(ind)      
       return result 
            
    """
    def call_raptor_for_all_stops_for_all_times_departure(self, mode):

      protocol_type = 2
      sources = []
      #Maximal_travel_time = int(self.dlg.txtAccessTime.text())*60
      #self.settings["Maximal_travel_time"] = Maximal_travel_time 
    
     
      begin_input_preparing = datetime.now()
      print(f'begin input preparing = {begin_input_preparing}')      
      
      pkl = PKL_class (PathToNetwork = self.settings["PathToNetwork"], NETWORK_NAME = self.settings["NETWORK_NAME"])
      stoptimes = pkl.get_stoptimes()

           
      # Обход словаря
      for route, trips in stoptimes.items():
        for trip_id, trip in trips.items():
            for stop_id, time in trip:
              
              sources.append((stop_id, time))


      # Сортировка sources по номеру остановки
      sources.sort(key=lambda x: x[0])
            
      end_input_preparing = datetime.now()
      print(f'end input preparing = {end_input_preparing}') 
            
      runRaptorWithProtocol(self, self.settings, sources, mode, protocol_type)
      
   """
    """
    Goal: call raptor for one source and all possible destinations from stops layer
     accessible for some maximal time. The source might be some real stop
     or some point on the map. In these case 
        
    """ 
    def callRaptorOneToMany(self ,mode):  
      self.break_on = False   
      self.setMessage ("Start calculating ...")
      QApplication.processEvents()
      protocol_type = self.getCurrentItemFromCombo(self.dlg.cmbProtocolType)
      self.readParameters()
      limit_text = self.dlg.txtLimit.text()

      D_TIME = self.settings["D_TIME"]
      date_format = "%Y-%m-%d %H:%M:%S"
      D_TIME = datetime.strptime(D_TIME, date_format)
      current_date = date.today()
      D_TIME = datetime.combine(current_date, D_TIME.time())
      self.settings["D_TIME"] = D_TIME
      
     
      sources = [] 

      if self.dlg.rb_one_point.isChecked():
                  
          if self.dlg.txtSourceID.text() == "" or not (self.dlg.txtSourceID.text().isdigit()):
            self.dlg.lblMessages.setText("Start point id should be defined and must be digit")
            return 
          sources.append((int(self.dlg.txtSourceID.text()), D_TIME))


      if (self.dlg.rb_one_point_from_layer.isChecked()):
      
          source_stop_id = self.getCurrentItemFromCombo(self.dlg.cmbResultsByCircle)
           
          if source_stop_id == "":
            self.dlg.lblMessages.setText("Start point id should be selected")
            return
          else :
            SOURCE = source_stop_id[0]
            if isinstance(SOURCE, str):
              SOURCE = int(SOURCE)
             
            sources.append((SOURCE, D_TIME))  

       

      if self.dlg.rb_many_points_from_layer.isChecked():
          if limit_text.isdigit() and int(limit_text) >= 0:
            limit = int(limit_text)
            stops = self.get_feature_from_layer(self.dlg.cmbLayers_2.currentText(), limit)
            if stops:
              for stop_id in stops:
                sources.append((stop_id, D_TIME))
            else:
              return 0
          else:
            self.setMessage("Error: limit value must be a non-negative number!")
            return 0
            

          
          
      
      if self.dlg.rb_many_points_from_PKL.isChecked():
          pkl = PKL_class (PathToNetwork = self.settings["PathToNetwork"], NETWORK_NAME = self.settings["NETWORK_NAME"])
          if limit_text.isdigit() and int(limit_text) >= 0:
            limit = int(limit_text)
            stops = pkl.get_stops(limit)
            for stop_id in stops:
              sources.append((stop_id, D_TIME))
          else:
            self.setMessage("Error: limit value must be a non-negative number!")
            return 0
      

      if self.dlg.rb_many_nearest_points.isChecked():
          txtLon_3 = self.dlg.txtLon_3.text()
          txtLat_3 = self.dlg.txtLat_3.text()

          if not(txtLon_3 and txtLat_3):
            self.setMessage("Need choice point on map")
            return 0
          
          if limit_text.isdigit() and int(limit_text) > 0:
            limit = int(limit_text)
            stops = self.get_nearest_feature_from_layer(self.dlg.cmbLayers_4.currentText(), float(txtLon_3), float(txtLon_3), limit)
            if stops:
              for stop_id in stops:
                sources.append((stop_id, D_TIME))
            else:
              return 0
          else:
            self.setMessage("Error: limit value must be greater than 0!")
            return 0  
      
      #time_step = 10 * 60
      #self.settings["time_step"] = time_step
      #self.settings["DESTINATION"] = 0 #should not be important 
            
      runRaptorWithProtocol(self, self.settings, sources, mode, protocol_type)
    
    def readParameters(self):
       f = open(module_path + "/parameters.txt", "r")
       for x in f:
        arr = x.split(",")
        key = arr[0]        
        value = arr[1].strip()
        
        self.settings[key] = value

    def saveParameters(self):
     f = module_path + "/parameters.txt" 
     with open(f, 'w') as filetowrite:
        
      settings = self.settings
      line = ""
      sep = ","
      for key in settings:
       line = ""

       if key == "MaxWalkDist1":                 
         line = self.dlg2.txtMaxWalkDist1.text()

       if key == "MaxWalkDist2":                 
         line = self.dlg2.txtMaxWalkDist2.text()
       if key == "MaxWalkDist3":                 
         line = self.dlg2.txtMaxWalkDist3.text()
       if key == "MaxWaitTime":                 
         line = self.dlg2.txtMaxWaitTime.text() 

       if key == "MaxTimeTravel":                 
         line = self.dlg2.txtMaxTimeTravel.text()

       if key == "PathToNetwork":                 
         line = self.dlg2.lineEdit.text()
       if key == "PathToProtocols":                 
         line = self.dlg2.txtPathToProtocos.text()  
       if key == "NETWORK_NAME":       
        line = self.dlg2.txtNetworkName.text()                
       elif key == "D_TIME": 
        line= self.dlg2.txtDate.text() + " " + self.dlg2.txtStartTime.text()
       elif key == "MAX_TRANSFER":        
        line = self.dlg2.txtMaxTransfers.text()
       elif key == "WALKING_FROM_SOURCE":
         if self.dlg2.chkWalkingFromSource.isChecked():           
          line = "1"
         else: 
          line = "0"
       elif key == "CHANGE_TIME_SEC":        
        line = self.dlg2.txtChangeTime.text()
       elif key == "VELOCITY":
        line = self.dlg2.txtVelocity.text()           
       elif key == "stopTolerance" :
         line = self.dlg2.txtRadius.text()  
       elif key == "ExactTransfersCount":
         if self.dlg2.chkExactTransfersCount.isChecked():
             line = "1"
         else:
             line = "0"              
       if line != "" :
        filetowrite.write(key + sep + line + '\n')  
    
       
    def get_save_shortest_paths(self):
      pass
      self.readParameters()
      PathToProtocols =self.settings["PathToProtocols"]
      # x1=float(self.dlg.txtLon.text())
      # y1=float(self.dlg.txtLat.text())
      # cmb= self.dlg.cmbResultsByCircle
      # SOURCE=self.getCurrentItemFromCombo(cmb)
      path_to_roads_layer=self.settings["path_to_roads_layer"]
      print("path_to_roads_layer="+path_to_roads_layer)
      
      directionFieldId = 5
      speedFieldId=22
      
      strategy_id=1 #speed
      SOURCE="322756135"
      x1=177021.757305
      y1=662029.492182
      points=[QgsPointXY(x1,y1)]
      main_shortest_paths_utils(SOURCE,PathToProtocols,path_to_roads_layer,directionFieldId,
                                speedFieldId,points,strategy_id)
      
    def handleSettingsDialogShown(self):
      self.readParameters()
      settings=self.settings
      for key in settings:
       
       if key=="MaxWalkDist1":         
         self.dlg2.txtMaxWalkDist1.setText(settings[key])
       if key=="MaxWalkDist2":         
         self.dlg2.txtMaxWalkDist2.setText(settings[key])
       if key=="MaxWalkDist3":         
         self.dlg2.txtMaxWalkDist3.setText(settings[key])    
       if key=="MaxWaitTime":         
         self.dlg2.txtMaxWaitTime.setText(settings[key])    

       if key=="MaxTimeTravel":         
         self.dlg2.txtMaxTimeTravel.setText(settings[key])     

       if key=="PathToNetwork":         
         self.dlg2.lineEdit.setText(settings[key])
       if key=="PathToProtocols":        
        self.dlg2.txtPathToProtocos.setText(settings[key])                  
       if key=="NETWORK_NAME":        
        self.dlg2.txtNetworkName.setText(settings[key])  
        
       elif key=="D_TIME": 
        
        #I want to separate day from hour
        temp=settings[key].split(" ")
        self.dlg2.txtDate.setText(temp[0])
        self.dlg2.txtStartTime.setText(temp[1])
       elif key== "MAX_TRANSFER":        
        self.dlg2.txtMaxTransfers.setText(settings[key])
       elif key=="WALKING_FROM_SOURCE":          
          if settings[key]=="1":            
            self.dlg2.chkWalkingFromSource.setChecked(True)
          else:
            self.dlg2.chkWalkingFromSource.setChecked(False)  
       elif key== "CHANGE_TIME_SEC":        
        self.dlg2.txtChangeTime.setText(settings[key])
       elif key== "VELOCITY":        
        self.dlg2.txtVelocity.setText(settings[key]) 
       elif key=="stopTolerance":
        self.dlg2.txtRadius.setText(settings[key]) 
       elif key=="ExactTransfersCount":
         if settings[key]=="1":            
            self.dlg2.chkExactTransfersCount.setChecked(True)
         else:
            self.dlg2.chkExactTransfersCount.setChecked(False)

    def on_radio_button_click (self):
      if self.dlg.rb_one_point.isChecked():
        self.dlg.txtSourceID.setEnabled(True)
        #self.dlg.txtSourceID.setReadOnly(False)
        self.dlg.groupBox.setEnabled(False)
        self.dlg.cmbLayers_2.setEnabled(False)
        self.dlg.groupBox_2.setEnabled(False)
        
      if self.dlg.rb_one_point_from_layer.isChecked():
        self.dlg.txtSourceID.setEnabled(False)
        self.dlg.groupBox.setEnabled(True)
        self.dlg.cmbLayers_2.setEnabled(False)
        self.dlg.groupBox_2.setEnabled(False)

      if self.dlg.rb_many_points_from_layer.isChecked():
        self.dlg.txtSourceID.setEnabled(False)
        self.dlg.groupBox.setEnabled(False)
        self.dlg.cmbLayers_2.setEnabled(True)
        self.dlg.groupBox_2.setEnabled(False)  

      if self.dlg.rb_many_points_from_PKL.isChecked():
        self.dlg.txtSourceID.setEnabled(False)
        self.dlg.groupBox.setEnabled(False)
        self.dlg.cmbLayers_2.setEnabled(False)
        self.dlg.groupBox_2.setEnabled(False)

      if self.dlg.rb_many_nearest_points.isChecked():
        self.dlg.txtSourceID.setEnabled(False)
        self.dlg.groupBox.setEnabled(False)
        self.dlg.cmbLayers_2.setEnabled(False)
        self.dlg.groupBox_2.setEnabled(True)       


    def set_break_on (self):
      self.break_on = True    

       
    def run(self):       
                            
        if self.first_start == True:
            
                                    
            self.first_start = False
            self.dlg = TAUNetCalcDialog()
            
            self.dlg.btngetShortestPaths.setVisible(False)

                        
            self.break_on = False
            self.readParameters()
            self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint)
            self.showAllLayersInCombo()            
            
            self.dlg.btnSourcePoint.clicked.connect(partial(self.getMapPoint,1))
            self.dlg.btnSourcePoint_3.clicked.connect(partial(self.getMapPoint,2))
            
            self.dlg.btnGetFeaturesByCircle.clicked.connect(partial(self.getFeaturesByBuffer))
                        
            

            self.dlg.btnCallRaptorMany.clicked.connect(partial(self.callRaptorOneToMany,1))
            self.dlg.btnCallRevRaptorMany.clicked.connect(partial(self.callRaptorOneToMany,2))

            self.dlg.btnBreakOn.clicked.connect(partial(self.set_break_on))

            
            widget_rb1 = self.dlg.grpSource.findChild(QWidget, 'widget_rb1')

            rb_one_point = widget_rb1.findChild(QRadioButton, 'rb_one_point')
            rb_one_point_from_layer = widget_rb1.findChild(QRadioButton, 'rb_one_point_from_layer')
            rb_many_points_from_layer = widget_rb1.findChild(QRadioButton, 'rb_many_points_from_layer')
            rb_many_points_from_PKL = widget_rb1.findChild(QRadioButton, 'rb_many_points_from_PKL')
            rb_many_nearest_points = widget_rb1.findChild(QRadioButton, 'rb_many_nearest_points')

            rb_one_point.toggled.connect(self.on_radio_button_click)
            rb_one_point_from_layer.toggled.connect(self.on_radio_button_click)
            rb_many_points_from_layer.toggled.connect(self.on_radio_button_click)
            rb_many_points_from_PKL.toggled.connect(self.on_radio_button_click)
            rb_many_nearest_points.toggled.connect(self.on_radio_button_click)

            
        
            self.dlg.txtSourceID.setEnabled(True)
            self.dlg.groupBox.setEnabled(False)
            self.dlg.cmbLayers_2.setEnabled(False)
            self.dlg.groupBox_2.setEnabled(False)

            
            self.dlg.btngetShortestPaths.clicked.connect(self.get_save_shortest_paths)
            
            self.fillProtocolTypeCombo()
            
            self.setLabelText()                            

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
       

    def runSettings(self):
       if self.first_start_settings == True:
            self.first_start_settings=False
            self.dlg2 =TAUNetSettingsCalcDialog() 
            self.first_start = True
            self.dlg2.toolButton.clicked.connect(self.showGTFSDialog) 
            self.dlg2.toolButton_2.clicked.connect(self.showProtocolDialog) 
            #self.dlg2.btnLoadGTFS.clicked.connect(self.loadGTFS) 
            #self.dlg2.btnLoadGTFS.clicked.connect(self.loadShapes)   
            self.dlg2.btnOk.clicked.connect(self.getSettings)  # from settings dialog form
            self.dlg2.btnCancel.clicked.connect(self.cancelSettings) # close settings dialog form without get settings
            self.dlg2.dialogShown.connect(self.handleSettingsDialogShown) # on load settings dialog form 
            
            
           
       self.dlg2.show()
       self.dlg2.exec_()       
     